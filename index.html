<!DOCTYPE html>
<html>
<head>
	<title>KLabeler</title>
<style>
	body {
		font-family: Helvetica, Arial, sans-seris;
		font-size: 11pt;
		color: #d0d0d0;
		background: #404040;
	}

	body a {
		color: #d0d0d0;
	}

</style>
<script>

	/*
		TODO list:
		* move to normalized coordinates
		* extract bbox data to client (including extreme points)
		* support images with different size/aspect ratio as the canvas
		* support multiple images
		* detect bad extreme points as early as possible (before end of box)
		* regular bbox mode
		* single point annotation mode

		LICENSES:
		* This is the "click1" sound:
		  https://www.zapsplat.com/music/metal-impact-small-plate-disc-hit-vibrate-and-resonate-2/
	*/

	class Point2D {
		constructor(x, y) {
			this.x = x;
			this.y = y;
		}
	}

	class BBox2D {
		constructor(startx, starty, width, height) {
			this.bmin = new Point2D(startx, starty);
			this.bmax = new Point2D(this.bmin.x + width, this.bmin.y + height);
		}

		set(startx, starty, width, height) {
			this.bmin.x = startx;
			this.bmin.y = starty;
			this.bmax.x = this.bmin.x + width;
			this.bmax.y = this.bmin.y + height;
		}

		isEmpty() {
			return (this.bmin.x >= this.bmax.y || this.bmin.y >= this.bmax.y);
		}

		// returns true if the point (x,y) is inside the bounding box.  Edges of the box
		// are treated as part of the box. 
		inside(x, y) {
			if (x >= this.bmin.x && x <= this.bmax.x &&
				y >= this.bmin.y && y <= this.bmax.y)
				return true;
			else
				return false;
		}

		// return area of bounding box
		area() {
			return (this.bmax.x - this.bmin.x) * (this.bmax.y - this.bmin.y);
		}

		// converts an array of four extreme points to a bbox
		static extremePointsToBBox(pts) {

			// pts[0] = left extreme
			// pts[1] = top extreme
			// pts[2] = right extreme
			// pts[3] = bottom extreme

			var startx = pts[0].x;
			var starty = pts[1].y;
			var endx = pts[2].x;
			var endy = pts[3].y;

			var b = new BBox2D(startx, starty, endx - startx, endy - starty);
			return b;
		}

		// converts an array of two points to a bbox.  The code makes no assumptions about
		// which point in the array is which corner of the bbox. 
		static twoPointsToBBox(pts) {

			var startx = Math.min(pts[0].x, pts[1].x);
			var starty = Math.min(pts[0].y, pts[1].y);
			var endx = Math.max(pts[0].x, pts[1].x);
			var endy = Math.max(pts[0].y, pts[1].y);

			var b = new BBox2D(startx, starty, endx - startx, endy - starty);
			return b;
		}

		// Returns true if this is a valid set of extreme points, false otherwise.
		//
		// To be valid, the first point should be the leftmost point, the second point
		// should be the uppermost one, the third point should be the rightmost,
		// and the fourth point should be bottommost.
		static validate_extreme_points(pts) {

			if (pts[0].x > pts[1].x ||
				pts[0].x > pts[2].x ||
				pts[0].x > pts[3].x)
				return false;
			if (pts[1].y > pts[1].y ||
				pts[1].y > pts[2].y ||
				pts[1].y > pts[3].y)
				return false;
			if (pts[2].x < pts[1].x ||
				pts[2].x < pts[2].x ||
				pts[2].x < pts[3].x)
				return false;
			if (pts[3].y < pts[1].y ||
				pts[3].y < pts[2].y ||
				pts[3].y < pts[3].y)
				return false;

			return true;
		}
	}

	// An Annotation stores the bounding box of the object and the extreme
	// points used to create the bounding box.  We don't want to disgard the extreme
	// points provided by the labeler since they contain additional information
	// about the object's silhouette that is lost if we just store the bounding box.  
	class Annotation {
		constructor(bbox, extremePoints) {
			this.bbox = bbox;
			this.extremePoints = extremePoints;
		}
	}

	class ImageLabeler {

		static get ANNOTATION_MODE_POINT() { return 0; }
		static get ANNOTATION_MODE_TWO_POINT_BBOX() { return 1; }
		static get ANNOTATION_MODE_EXTREME_POINTS_BBOX() { return 2; }

		constructor() {

			this.main_canvas_el = null;

			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;

			this.image_loaded = false;
			this.source_image = new Image;

			this.audio_click_sound = null;
			this.audio_box_done_sound = null;

			this.annotation_mode = ImageLabeler.ANNOTATION_MODE_EXTREME_POINTS_BBOX;
			this.annotations = []
			this.inProgressPoints = [];

			this.spaceKeyDown = false;
			this.shiftKeyDown = false;

			// colors
			this.color_main_canvas = '#c0c0c0';
			//this.color_zoom_canvas = '#404040';
			this.color_cursor_lines = 'rgba(0,255,255,0.5)';
			this.color_in_progress_box_outline = 'rgba(255,255,255,0.75)';
			this.color_box_outline = 'rgba(255,200,0,0.75)';
			this.color_highlight_box_outline = 'rgba(255,200,100,1.0)';
			this.color_highlight_box_fill = 'rgba(255,200,150,0.2)';
			this.color_extreme_point_fill = '#ffff00';

			// display settings
			this.visible_image_region = new BBox2D(0.0, 0.0, 1.0, 1.0);
			this.letterbox_image = true;         // if false, stretch image
			this.play_audio = false;
			this.show_extreme_points = true;
			this.extreme_point_radius = 3;
		}

		// Clamp the cursor to the image dimensions so that clicks and bounding boxes
		// are always on the image.
		set_canvas_cursor_position(x,y) {
			this.cursorx = Math.min(this.main_canvas_el.width-1, Math.max(0, x));
			this.cursory = Math.min(this.main_canvas_el.height-1, Math.max(0, y));	
		}

		// convert point in canvas pixel coordinates to normalized [0,1]^2 image space coordinates
		canvas_to_image(pt) {
			return;
		}

		// convert point in normalized [0,1]^2 image space coordinates to canvas pixel coordinates
		image_to_canvas(pt) {
			return;
		}

		is_hovering() {
			return (this.cursorx >= 0 && this.cursory >= 0);
		}

		is_annotation_mode_point() {
			return this.annotation_mode == ImageLabeler.ANNOTATION_MODE_POINT;
		}

		is_annotation_mode_two_point_bbox() {
			return this.annotation_mode == ImageLabeler.ANNOTATION_MODE_TWO_POINT_BBOX;
		}

		is_annotation_mode_extreme_points_bbox() {
			return this.annotation_mode == ImageLabeler.ANNOTATION_MODE_EXTREME_POINTS_BBOX;
		}

		// returns the index of the box that is the "selected box" given the current moue position
		get_selected_object() {

			var selected = -1;

			if (!this.is_hovering())
				return selected;

			// select the smallest box that the cursor is in
			var smallest_area = Number.MAX_VALUE;
			for (var i=0; i<this.annotations.length; i++) {
				if (this.annotations[i].bbox.inside(this.cursorx, this.cursory) &&
					this.annotations[i].bbox.area() < smallest_area) {
					selected = i;
					smallest_area = this.annotations[i].bbox.area();
				}
			}

			return selected;			
		}

		clear_in_progress_points() {
			this.inProgressPoints = [];
		}

		delete_box() {
			var selected = this.get_selected_object();

			if (selected != -1) {
				this.annotations.splice(selected, 1);
				console.log("KLabeler: Deleted box " + selected);
			}

			this.render();
		}

		clear_boxes() {
			var num_annotations = this.annotations.length;
			this.annotations = [];
			this.clear_in_progress_points();
			this.render();
			console.log("Cleared all " + num_annotations + " boxes.");
		}

		set_extreme_points_viz(status) {
			this.show_extreme_points = status;
			this.render();
		}

		set_play_audio(toggle) {
			this.play_audio = toggle;
		}

		set_letterbox(toggle) {
			this.letterbox_image = toggle;
			this.render();
		}

		set_image(url) {
			// initiate loading of the image to label
			console.log('KLabeler: Loading image: ' + url);
			this.source_image.src = url;
		}

		play_click_audio() {

			// if there are no in progress points, then this must be the last click needed to
			// make an annotation play the sound corresponding to a finished annotation. 
			if (this.inProgressPoints.length == 0) {

				// stop other sounds
				this.audio_click_sound.pause();

				// play the end of box sound

				// if the sound is aready playing then the subsequent call to play() will do nothing
				// and the audio will keep playing from that point it is currently at.
				// (Or if the audio is paused, play() will resume from the paused point)
				// So I reset the playpack point of the sound to the start of the timeline so that
				// the sound plays again from the start.
				this.audio_box_done_sound.currentTime = 0.0;					
				this.audio_box_done_sound.play();

			} else {

				// stop other sounds
				this.audio_box_done_sound.pause();

				// play the click sound
				this.audio_click_sound.currentTime = 0.0;					
				this.audio_click_sound.play();
			}
		}

		draw_inprogress_extreme_points_bbox(ctx) {

			// draw the points we've locked down
			ctx.beginPath();
			ctx.moveTo(this.inProgressPoints[0].x, this.inProgressPoints[0].y);
			for (var i=1; i<this.inProgressPoints.length; i++) {
				var cornerx = 0;
				var cornery = 0;
				if (i == 1) {
					cornerx = this.inProgressPoints[0].x;
					cornery = this.inProgressPoints[1].y;
				} else if (i == 2) {
					cornerx = this.inProgressPoints[2].x;
					cornery = this.inProgressPoints[1].y;
				} else if (i == 3) {
					cornerx = this.inProgressPoints[0].x;
					cornery = this.inProgressPoints[3].y;
				}
				ctx.lineTo(cornerx, cornery);
			}

			// now draw the tentative point
			if (this.is_hovering()) {
				if (this.inProgressPoints.length == 1) {
					ctx.lineTo(this.inProgressPoints[0].x, this.cursory);		
					ctx.lineTo(this.cursorx, this.cursory);
				} else if (this.inProgressPoints.length == 2) {
					ctx.lineTo(this.cursorx, this.inProgressPoints[1].y);
					ctx.lineTo(this.cursorx, this.cursory);
				} else if (this.inProgressPoints.length == 3) {
					ctx.lineTo(this.inProgressPoints[2].x, this.cursory);
					// extrapolation of rest of box
					ctx.lineTo(this.inProgressPoints[0].x, this.cursory);
					ctx.lineTo(this.inProgressPoints[0].x, this.inProgressPoints[0].y);
				}
			}
			ctx.stroke();

			// draw dots at all the extreme points
			var full_circle_angle = 2 * Math.PI;
			ctx.fillStyle = this.color_extreme_point_fill;
			for (var i=0; i<this.inProgressPoints.length; i++) {
				ctx.beginPath();
  				ctx.arc(this.inProgressPoints[i].x, this.inProgressPoints[i].y, this.extreme_point_radius, 0, full_circle_angle, false);
		        ctx.fill();
			}	
		}

		draw_inprogress_two_points_bbox(ctx) {

			var pts = []
			pts.push(this.inProgressPoints[0]);
			pts.push(new Point2D(this.cursorx, this.cursory));

			var box = BBox2D.twoPointsToBBox(pts);
			var w = box.bmax.x - box.bmin.x;
			var h = box.bmax.y - box.bmin.y;
			ctx.strokeRect(box.bmin.x, box.bmin.y, w, h);
		}

		/*
		// this is deprecated since we don't want the zoom view any more.
		render_zoom_view() {

			var ctx = this.zoom_canvas_el.getContext('2d');
			ctx.clearRect(0, 0, this.zoom_canvas_el.width, this.zoom_canvas_el.height);

			ctx.fillStyle = this.color_zoom_canvas;
			ctx.fillRect(0, 0, this.zoom_canvas_el.width, this.zoom_canvas_el.height);

			if (this.is_hovering()) {

				// draw zoomed view of image
				var sw = this.zoom_canvas_el.width / this.zoom_factor;
				var sh = this.zoom_canvas_el.height / this.zoom_factor;
				var sx = this.source_image.width * this.cursorx / this.main_canvas_el.width - (sw / 2);
				var sy = this.source_image.height * this.cursory / this.main_canvas_el.height - (sh / 2);

				ctx.imageSmoothingEnabled = false;
				ctx.drawImage(this.source_image, sx, sy, sw, sh, 0, 0, this.zoom_canvas_el.width, this.zoom_canvas_el.height);

				// draw zoomed in cursor 
				ctx.lineWidth = this.zoom_factor;
				ctx.strokeStyle = this.color_cursor_lines;

				// lines with greater that one pixel thickness are "centered" about the specified endpoints
				// offset the line so that that (potentially) thick line is aligned with the pixels in the visualization
				var offsetx = ctx.lineWidth / 2;
				var offsety = ctx.lineWidth / 2;

				ctx.beginPath();
				ctx.moveTo(this.zoom_canvas_el.width/2 - offsetx, 0);
				ctx.lineTo(this.zoom_canvas_el.width/2 - offsetx, this.zoom_canvas_el.height);
				ctx.stroke();

				ctx.beginPath();
				ctx.moveTo(0, this.zoom_canvas_el.height/2 - offsety);
				ctx.lineTo(this.zoom_canvas_el.width, this.zoom_canvas_el.height/2  - offsety);
				ctx.stroke();
			}
		}
		*/

		render_image() {

			var ctx = this.main_canvas_el.getContext('2d');

			// visible region of the image in the image's pixel space
			var visible_xmin = this.visible_image_region.bmin.x * this.source_image.width;
			var visible_ymin = this.visible_image_region.bmin.y * this.source_image.height;
			var visible_xmax = this.visible_image_region.bmax.x * this.source_image.width;
			var visible_ymax = this.visible_image_region.bmax.y * this.source_image.height;

			var visible_width  = visible_xmax - visible_xmin;
			var visible_height = visible_ymax - visible_ymin;

			if (this.letterbox_image) {

				var aspect_canvas = this.main_canvas_el.height / this.main_canvas_el.width;
				var aspect_visible  = visible_height / visible_width;

				if (aspect_canvas >= aspect_visible) {
					// canvas is taller than the visible part of the image, so letterbox the top and bottom
					var display_width = this.main_canvas_el.width;
					var display_height = this.main_canvas_el.width * aspect_visible;
					var startx = 0; 
					var starty = (this.main_canvas_el.height - display_height) / 2;

					ctx.drawImage(this.source_image,
						visible_xmin, visible_ymin, visible_width, visible_height,
						startx, starty, display_width, display_height);

				} else {
					// canvas is wider than the visible part of the image, so letterbox the left and right
					var display_height = this.main_canvas_el.height;
					var display_width = this.main_canvas_el.height / aspect_visible;
					var startx = (this.main_canvas_el.width - display_width) / 2;
					var starty = 0; 

					ctx.drawImage(this.source_image,
						visible_xmin, visible_ymin, visible_width, visible_height,
						startx, starty, display_width, display_height);
				}
			} else {
				// scale the image to fill the entire canvas
				ctx.drawImage(this.source_image,
					visible_xmin, visible_ymin, visible_width, visible_height,
					0, 0, this.main_canvas_el.width, this.main_canvas_el.height);
			}

		}

		render() {

			var ctx = this.main_canvas_el.getContext('2d');

			ctx.clearRect(0, 0, this.main_canvas_el.width, this.main_canvas_el.height);

			// draw the image to label

			if (this.image_loaded) {
				this.render_image();
			} else {
				ctx.fillStyle = this.color_main_canvas;
				ctx.fillRect(0, 0, this.main_canvas_el.width, this.main_canvas_el.height);
			}

			// draw guidelines that move with the mouse cursor

			if (this.is_hovering()) {
				ctx.lineWidth = 1;
				ctx.strokeStyle = this.color_cursor_lines;

				ctx.beginPath();
				ctx.moveTo(this.cursorx, 0);
				ctx.lineTo(this.cursorx, this.main_canvas_el.height);
				ctx.stroke();

				ctx.beginPath();
				ctx.moveTo(0, this.cursory);
				ctx.lineTo(this.main_canvas_el.width, this.cursory);
				ctx.stroke();
			}

			// draw existing bounding boxes
			
			var selected = this.get_selected_object();

			for (var obj_id=0; obj_id<this.annotations.length; obj_id++) {

				var obj = this.annotations[obj_id];
				var selectedObj = (selected == obj_id);

				var w = obj.bbox.bmax.x - obj.bbox.bmin.x;
				var h = obj.bbox.bmax.y - obj.bbox.bmin.y;

				// highlight the selected box
				if (selectedObj) {
					ctx.lineWidth = 3;
					ctx.strokeStyle = this.color_highlight_box_outline;
					ctx.fillStyle = this.color_highlight_box_fill;
					ctx.fillRect(obj.bbox.bmin.x, obj.bbox.bmin.y, w, h);
				} else {
					ctx.lineWidth = 2;
					ctx.strokeStyle = this.color_box_outline;
				}

				ctx.strokeRect(obj.bbox.bmin.x, obj.bbox.bmin.y, w, h);

				// draw dots indicating all the extreme points (if there are extreme points)
				if (this.show_extreme_points && obj.extreme_points !== undefined)  {
					var full_circle_angle = 2 * Math.PI;
					ctx.fillStyle = this.color_extreme_point_fill;
					for (var i=0; i<4; i++) {
						ctx.beginPath();
	      				ctx.arc(obj.extremePoints[i].x, obj.extremePoints[i].y, this.extreme_point_radius, 0, full_circle_angle, false);
				        ctx.fill();
					}
				}	
			}

			// render the "in-progress" points (the current partial bounding box)

			if (this.inProgressPoints.length > 0) {

				ctx.lineWidth = 1;
				ctx.strokeStyle = this.color_in_progress_box_outline; 

				if (this.is_annotation_mode_extreme_points_bbox()) {
					this.draw_inprogress_extreme_points_bbox(ctx);
				} else if (this.is_annotation_mode_two_point_bbox()) {
					this.draw_inprogress_two_point_bbox(ctx);
				}
			}

		}

		handle_image_load = event => {
			console.log("KLabeler: Image loaded.");
			this.image_loaded = true;
			this.visible_image_region = new BBox2D(0.0, 0.0, 1.0, 1.0);  // entire image is visible (zoomed out)
			this.render();
		}

		handle_canvas_mousemove = event => {
			this.set_canvas_cursor_position(event.offsetX, event.offsetY);
			this.render();
		}

		handle_canvas_mouseover = event => {
			this.set_canvas_cursor_position(event.offsetX, event.offsetY);		
			this.render();
		}

		handle_canvas_mouseout = event => {
			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;
			this.render();
		}

		handle_keydown = event => {
			//console.log("KeyDown: " + event.keyCode);

			if (event.keyCode == 32) {
				this.spaceKeyDown = true;
			} else if (event.keyCode == 16) {
				this.shiftKeyDown = true;
			}
		}

		handle_keyup = event => {
			//console.log("KeyUp: " + event.keyCode);

			if (event.keyCode == 32) {
				this.spaceKeyDown = false;
			} else if (event.keyCode == 16) {
				this.shiftKeyDown = false;
			} else if (event.keyCode == 8) {
				this.delete_box();
			}
		}

		handle_canvas_click = event => {

			this.set_canvas_cursor_position(event.offsetX, event.offsetY);

			var p = new Point2D(this.cursorx, this.cursory);
			this.inProgressPoints.push(p);

			console.log("KLabeler: Click at x=" + p.x + ", y=" + p.y + " point " + this.inProgressPoints.length);

			// if the labeler is configured to be in extreme points mode, after each click determine whether we
			// have a alid set of extreme points. 
			/*
			if (this.is_annotation_mode_extreme_points_bbox() && this.inProgressPoints.length < 4) {
				if (!BBox2D.validate_extreme_points(this.inProgressPoints)) {
					console.log("KLabeler: Points clicked are not valid extreme points. Discarding box.");
					this.clear_in_progress_points();
					this.render();
					return;
				}
			}
			*/

			// handle cases where this click completes a new annotation
			// (e.g., a new bounding box annotation or a new point annotation)
			if (this.is_annotation_mode_extreme_points_bbox() && this.inProgressPoints.length == 4) {

				// discard box if this set of four extreme points is not a valid set of extreme points
				if (!BBox2D.validate_extreme_points(this.inProgressPoints)) {
					console.log("KLabeler: Points clicked are not valid extreme points. Discarding box.");
					this.clear_in_progress_points();
					this.render();
					return;
				}

				var newBBox = BBox2D.extremePointsToBBox(this.inProgressPoints);
				var newAnnotation = new Annotation(newBBox, this.inProgressPoints);

				this.annotations.push(newAnnotation);

				console.log("KLabeler: New box: x=[" + newBBox.bmin.x + ", " + newBBox.bmax.y + "], y=[" + newBBox.bmin.y + ", " + newBBox.bmax.y + "]");
				console.log("KLabeler: There are now " + this.annotations.length + " box(es).");

				this.clear_in_progress_points();

			} else if (this.is_annotation_mode_two_point_bbox() && this.inProgressPoints.length == 2) {

				// validate box by discarding empty boxes.
				if (this.inProgressPoints[0].x == this.inProgressPoints[1].x &&
					this.inProgressPoints[0].y == this.inProgressPoints[1].y) {
					alert("Empty bbox. Discarding box.");
					this.clear_in_progress_points();
					this.render();
					return;
				}

				var newBBox = BBox2D.twoPointsToBBox(this.inProgressPoints);
				var newAnnotation = new Annotation(newBBox);
				this.annotations.push(newAnnotation);

				console.log("KLabeler: New box: x=[" + newBBox.bmin.x + ", " + newBBox.bmax.y + "], y=[" + newBBox.bmin.y + ", " + newBBox.bmax.y + "]");
				console.log("KLabeler: There are now " + this.annotations.length + " box(es).");

				this.clear_in_progress_points();

			} else if (this.is_annotation_mode_two_point_bbox()) {

				console.log("KLabeler: Annotation of points is not supported yet!");
				this.clear_in_progress_points();
			}

			this.render();

			if (this.play_audio)
				this.play_click_audio();
		}

		init(main_canvas_el) {

			console.log("Klabeler: initializing.");

			this.main_canvas_el = main_canvas_el;
			this.main_canvas_el.addEventListener("mousemove", this.handle_canvas_mousemove, false);
			this.main_canvas_el.addEventListener("click", this.handle_canvas_click, false);
			this.main_canvas_el.addEventListener("mouseover", this.handle_canvas_mouseover, false);
			this.main_canvas_el.addEventListener("mouseout", this.handle_canvas_mouseout, false);

			this.source_image.onload = this.handle_image_load;

			this.audio_click_sound = new Audio("media/click_sound2.mp3");
			this.audio_box_done_sound = new Audio("media/click_sound3.mp3");
		}
	}


	////////////////////////////////////////////////////////////////////////////////////
	// begin top-level code
	////////////////////////////////////////////////////////////////////////////////////

	var main_canvas_id = 'main_canvas';
	//var zoom_canvas_id = 'zoom_canvas';
	var labeler = new ImageLabeler;

	function handle_onload() {

		var main_canvas = document.getElementById(main_canvas_id);
		//var zoom_canvas = document.getElementById(zoom_canvas_id);
		labeler.init(main_canvas);
		labeler.set_image("media/testimage.jpg");
		//labeler.set_zoom_factor(8);

		var button = document.getElementById("toggle_pt_viz_button");
		button.toggle_status = true;
		labeler.set_extreme_points_viz(button.toggle_status);

		button = document.getElementById("toggle_sound_button");
		button.toggle_status = true;
		labeler.set_play_audio(button.toggle_status);

		button = document.getElementById("toggle_letterbox_button");
		button.toggle_status = true;
		labeler.set_letterbox(button.toggle_status);

		// HACK(kayvonf): intercept all key events and send them to the labeler
		// There's likely a much better way to do this.
		// The problem is that the Klabeler canvas DOM element needs to have keyboard focus in order to accept key events.
		// I'm not certain I want to do that right now, since other elements of the HTML page might want keyboard focus,
		// so for now I'm going to send all key events on the page to the KLabeler cnavas.
		window.addEventListener("keydown", function(e) {
			e.preventDefault();
			labeler.handle_keydown(e);
		});

		window.addEventListener("keyup", function(e) {
			e.preventDefault();
			labeler.handle_keyup(e);
		});
	}

	function clear_boxes() {
		labeler.clear_boxes();
	}

	function toggle_extreme_points_display() {
		var button = document.getElementById("toggle_pt_viz_button");
		var new_status = !button.toggle_status;
		labeler.set_extreme_points_viz(new_status);
		button.toggle_status = new_status;

		if (new_status == false) {
			button.innerHTML = 'Show Extreme Points';
		} else {
			button.innerHTML = 'Hide Extreme Points';
		}
	}

	function toggle_sound() {
		var button = document.getElementById("toggle_sound_button");
		var new_status = !button.toggle_status;
		labeler.set_play_audio(new_status);
		button.toggle_status = new_status;

		if (new_status == false) {
			button.innerHTML = 'Turn Sound On';
		} else {
			button.innerHTML = 'Turn Sound Off';
		}		
	}

	function toggle_letterbox() {
		var button = document.getElementById("toggle_letterbox_button");
		var new_status = !button.toggle_status;	
		labeler.set_letterbox(new_status);
		button.toggle_status = new_status;

		if (new_status == false) {
			button.innerHTML = 'Use Letterbox View';
		} else {
			button.innerHTML = 'Use Scaled View';
		}
	}

</script>
</head>
<body onload="handle_onload()">

<div id="labeled_div">
	<canvas id="main_canvas" width="960" height="440" style="border: 8px solid #c0c0c0;" ></canvas>
	<!-- <canvas id="zoom_canvas" width="270" height="270" style="border: 8px solid #c0c0c0;"></canvas> -->
</div>

<div>
	<button id="clear_button" type="button" onclick="clear_boxes()">Clear Boxes</button>
	<button id="toggle_pt_viz_button" type="button" onclick="toggle_extreme_points_display()">Hide Extreme Points</button>
	<button id="toggle_sound_button" type="button" onclick="toggle_sound()">Turn Sound On</button>
	<button id="toggle_letterbox_button" type="button" onclick="toggle_letterbox()">Scale Image</button>
</div>

<p>Click four times to draw a box.  (Use the <a href="https://arxiv.org/abs/1708.02750">extreme clicking</a> technique: leftmost, topmost, rightmost, bottommost)</p>
<p>Hover over a box to select it. Press DEL to delete the selected box. (Selection picks the smallest area box containing the cursor.)</p>

</body>
</html>