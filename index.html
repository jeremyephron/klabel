<!DOCTYPE html>
<html>
<head>
	<title>KLabeler</title>
<style>
	body {
		font-family: Helvetica, Arial, sans-seris;
		font-size: 11pt;
		color: #d0d0d0;
		background: #404040;
	}

	body a {
		color: #d0d0d0;
	}

</style>
<script>

	/*
		TODO list:
		* move to normalized coordinates
		* extract bbox data to client (including extreme points)
		* support images with different size/aspect ratio as the canvas
		* support multiple images
		* detect bad extreme points as early as possible
		* regular bbox mode
		* single point annotation mode

		LICENSES:
		* This is the "click1" sound:
		  https://www.zapsplat.com/music/metal-impact-small-plate-disc-hit-vibrate-and-resonate-2/
	*/

	class Point2D {
		constructor(x, y) {
			this.x = x;
			this.y = y;
		}
	}

	class BBox2D {
		constructor(startx, starty, width, height) {
			this.bmin = new Point2D(startx, starty);
			this.bmax = new Point2D(this.bmin.x + width, this.bmin.y + height);
		}

		set(startx, starty, width, height) {
			this.bmin.x = startx;
			this.bmin.y = starty;
			this.bmax.x = this.bmin.x + width;
			this.bmax.y = this.bmin.y + height;
		}

		isEmpty() {
			return (this.bmin.x >= this.bmax.y || this.bmin.y >= this.bmax.y);
		}

		// returns true if the point (x,y) is inside the bounding box.  Edges of the box
		// are treated as part of the box. 
		inside(x, y) {
			if (x >= this.bmin.x && x <= this.bmax.x &&
				y >= this.bmin.y && y <= this.bmax.y)
				return true;
			else
				return false;
		}

		// return area of bounding box
		area() {
			return (this.bmax.x - this.bmin.x) * (this.bmax.y - this.bmin.y);
		}

		// converts an array of four extreme points to a bbox
		static extremePointsToBBox(pts) {

			// pts[0] = left extreme
			// pts[1] = top extreme
			// pts[2] = right extreme
			// pts[3] = bottom extreme

			var startx = pts[0].x;
			var starty = pts[1].y;
			var endx = pts[2].x;
			var endy = pts[3].y;

			var b = new BBox2D(startx, starty, endx - startx, endy - starty);
			return b;
		}

		// converts an array of two points to a bbox.  The code makes no assumptions about
		// which point in the array is which corner of the bbox. 
		static twoPointsToBBox(pts) {

			var startx = Math.min(pts[0].x, pts[1].x);
			var starty = Math.min(pts[0].y, pts[1].y);
			var endx = Math.max(pts[0].x, pts[1].x);
			var endy = Math.max(pts[0].y, pts[1].y);

			var b = new BBox2D(startx, starty, endx - startx, endy - starty);
			return b;
		}

		// Returns true if this is a valid set of extreme points, false otherwise.
		//
		// To be valid, the first point should be the leftmost point, the second point
		// should be the uppermost one, the third point should be the rightmost,
		// and the fourth point should be bottommost.
		static valid_extreme_points(pts) {
			if (pts[0].x > pts[1].x ||
				pts[0].x > pts[2].x ||
				pts[0].x > pts[3].x)
				return false;
			if (pts[1].y > pts[1].y ||
				pts[1].y > pts[2].y ||
				pts[1].y > pts[3].y)
				return false;
			if (pts[2].x < pts[1].x ||
				pts[2].x < pts[2].x ||
				pts[2].x < pts[3].x)
				return false;
			if (pts[3].y < pts[1].y ||
				pts[3].y < pts[2].y ||
				pts[3].y < pts[3].y)
				return false;
			return true;
		}
	}

	// An Annotation stores the bounding box of the object and the extreme
	// points used to create the bounding box.  We don't want to disgard the extreme
	// points provided by the labeler since they contain additional information
	// about the object's silhouette that is lost if we just store the bounding box.  
	class Annotation {
		constructor(bbox, extremePoints) {
			this.bbox = bbox;
			this.extremePoints = extremePoints;
		}
	}

	class ImageLabeler {

		static get ANNOTATION_MODE_POINTS() { return 0; }
		static get ANNOTATION_MODE_REGULAR_BBOX() { return 1; }
		static get ANNOTATION_MODE_EXTREME_BBOX() { return 2; }

		constructor() {

			this.main_canvas_el = null;
			this.main_canvas_width = 0;
			this.main_canvas_height = 0;
			this.zoom_canvas_el = null;
			this.zoom_canvas_width = 0;
			this.zoom_canvas_height = 0;

			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;

			this.image_loaded = false;
			this.source_image = new Image;

			this.audio_click_sound = null;
			this.audio_box_done_sound = null;

			this.annotation_mode = ImageLabeler.ANNOTATION_MODE_REGULAR_BBOX;
			this.annotations = []
			this.inProgressPoints = [];

			this.spaceKeyDown = false;
			this.shiftKeyDown = false;

			// colors
			this.color_main_canvas = '#c0c0c0';
			this.color_zoom_canvas = '#404040';
			this.color_cursor_lines = 'rgba(0,255,255,0.5)';
			this.color_in_progress_box_outline = 'rgba(255,255,255,0.75)';
			this.color_box_outline = 'rgba(255,200,0,0.75)';
			this.color_highlight_box_outline = 'rgba(255,200,100,1.0)';
			this.color_highlight_box_fill = 'rgba(255,200,150,0.2)';
			this.color_extreme_point_fill = '#ffff00';

			this.play_audio = false;
			this.zoom_factor = 4;
			this.show_extreme_points = true;
			this.extreme_point_radius = 3;
			
		}

		// Clamp the cursor to the image dimensions so that clicks and bounding boxes
		// are always on the image.
		set_cursor_position(x,y) {
			this.cursorx = Math.min(this.main_canvas_width-1, Math.max(0, x));
			this.cursory = Math.min(this.main_canvas_height-1, Math.max(0, y));	
		}

		is_hovering() {
			return (this.cursorx >= 0 && this.cursory >= 0);
		}

		zoom_view_enabled() {
			return !(this.zoom_canvas_el === undefined);
		}

		is_mode_regular_bbox() {
			return this.annotation_mode == ImageLabeler.ANNOTATION_MODE_REGULAR_BBOX;
		}

		is_mode_extreme_bbox() {
			return this.annotation_mode == ImageLabeler.ANNOTATION_MODE_EXTREME_BBOX;
		}

		// returns the index of the box that is the "selected box" given the current moue position
		get_selected_object() {

			var selected = -1;

			if (!this.is_hovering())
				return selected;

			// select the smallest box that the cursor is in
			var smallest_area = Number.MAX_VALUE;
			for (var i=0; i<this.annotations.length; i++) {
				if (this.annotations[i].bbox.inside(this.cursorx, this.cursory) &&
					this.annotations[i].bbox.area() < smallest_area) {
					selected = i;
					smallest_area = this.annotations[i].bbox.area();
				}
			}

			return selected;			
		}

		delete_box() {
			var selected = this.get_selected_object();

			if (selected != -1) {
				this.annotations.splice(selected, 1);
				console.log("KLabeler: Deleted box " + selected);
			}

			this.render();
		}


		play_click_audio() {

			// if there are no in progress points, then this must be the last click needed to
			// make an annotation play the sound corresponding to a finished annotation. 
			if (this.inProgressPoints.length == 0) {

				// stop other sounds
				this.audio_click_sound.pause();

				// play the end of box sound

				// if the sound is aready playing then the subsequent call to play() will do nothing
				// and the audio will keep playing from that point it is currently at.
				// (Or if the audio is paused, play() will resume from the paused point)
				// So I reset the playpack point of the sound to the start of the timeline so that
				// the sound plays again from the start.
				this.audio_box_done_sound.currentTime = 0.0;					
				this.audio_box_done_sound.play();


			} else {

				// stop other sounds
				this.audio_box_done_sound.pause();

				// play the click sound
				this.audio_click_sound.currentTime = 0.0;					
				this.audio_click_sound.play();
			}
		}

		set_zoom_factor(zoom) {
			this.zoom_factor = zoom;
			this.render();
		}

		set_extreme_points_viz(status) {
			this.show_extreme_points = status;
			this.render();
		}

		set_play_audio(toggle) {
			this.play_audio = toggle;
		}

		set_image(url) {
			// initiate loading of the image to label
			console.log('KLabeler: Loading image: ' + url);
			this.source_image.src = url;
		}

		clear_boxes() {
			var num_annotations = this.annotations.length;
			this.inProgressPoints = [];
			this.annotations = [];
			this.render();
			console.log("Cleared all " + num_annotations + " boxes.");
		}

		draw_inprogress_extreme_bbox(ctx) {

			// draw the points we've locked down
			ctx.beginPath();
			ctx.moveTo(this.inProgressPoints[0].x, this.inProgressPoints[0].y);
			for (var i=1; i<this.inProgressPoints.length; i++) {
				var cornerx = 0;
				var cornery = 0;
				if (i == 1) {
					cornerx = this.inProgressPoints[0].x;
					cornery = this.inProgressPoints[1].y;
				} else if (i == 2) {
					cornerx = this.inProgressPoints[2].x;
					cornery = this.inProgressPoints[1].y;
				} else if (i == 3) {
					cornerx = this.inProgressPoints[0].x;
					cornery = this.inProgressPoints[3].y;
				}
				ctx.lineTo(cornerx, cornery);
			}

			// now draw the tentative point
			if (this.is_hovering()) {
				if (this.inProgressPoints.length == 1) {
					ctx.lineTo(this.inProgressPoints[0].x, this.cursory);		
					ctx.lineTo(this.cursorx, this.cursory);
				} else if (this.inProgressPoints.length == 2) {
					ctx.lineTo(this.cursorx, this.inProgressPoints[1].y);
					ctx.lineTo(this.cursorx, this.cursory);
				} else if (this.inProgressPoints.length == 3) {
					ctx.lineTo(this.inProgressPoints[2].x, this.cursory);
					// extrapolation of rest of box
					ctx.lineTo(this.inProgressPoints[0].x, this.cursory);
					ctx.lineTo(this.inProgressPoints[0].x, this.inProgressPoints[0].y);
				}
			}
			ctx.stroke();

			// draw dots at all the extreme points
			var full_circle_angle = 2 * Math.PI;
			ctx.fillStyle = this.color_extreme_point_fill;
			for (var i=0; i<this.inProgressPoints.length; i++) {
				ctx.beginPath();
  				ctx.arc(this.inProgressPoints[i].x, this.inProgressPoints[i].y, this.extreme_point_radius, 0, full_circle_angle, false);
		        ctx.fill();
			}	
		}

		draw_inprogress_regular_bbox(ctx) {

			var pts = []
			pts.push(this.inProgressPoints[0]);
			pts.push(new Point2D(this.cursorx, this.cursory));

			var box = BBox2D.twoPointsToBBox(pts);
			var w = box.bmax.x - box.bmin.x;
			var h = box.bmax.y - box.bmin.y;
			ctx.strokeRect(box.bmin.x, box.bmin.y, w, h);
		}

		render_zoom_view() {

			var ctx = this.zoom_canvas_el.getContext('2d');
			ctx.clearRect(0, 0, this.zoom_canvas_el.width, this.zoom_canvas_el.height);

			ctx.fillStyle = this.color_zoom_canvas;
			ctx.fillRect(0, 0, this.zoom_canvas_width, this.zoom_canvas_height);

			if (this.is_hovering()) {

				// draw zoomed view of image
				var sw = this.zoom_canvas_width / this.zoom_factor;
				var sh = this.zoom_canvas_height / this.zoom_factor;
				var sx = this.source_image.width * this.cursorx / this.main_canvas_width - (sw / 2);
				var sy = this.source_image.height * this.cursory / this.main_canvas_height - (sh / 2);

				ctx.imageSmoothingEnabled = false;
				ctx.drawImage(this.source_image, sx, sy, sw, sh, 0, 0, this.zoom_canvas_width, this.zoom_canvas_height);

				// draw zoomed in cursor 
				ctx.lineWidth = this.zoom_factor;
				ctx.strokeStyle = this.color_cursor_lines;

				// lines with greater that one pixel thickness are "centered" about the specified endpoints
				// offset the line so that that (potentially) thick line is aligned with the pixels in the visualization
				var offsetx = ctx.lineWidth / 2;
				var offsety = ctx.lineWidth / 2;

				ctx.beginPath();
				ctx.moveTo(this.zoom_canvas_width/2 - offsetx, 0);
				ctx.lineTo(this.zoom_canvas_width/2 - offsetx, this.zoom_canvas_height);
				ctx.stroke();

				ctx.beginPath();
				ctx.moveTo(0, this.zoom_canvas_height/2 - offsety);
				ctx.lineTo(this.zoom_canvas_width, this.zoom_canvas_height/2  - offsety);
				ctx.stroke();
			}
		}

		render() {

			var ctx = this.main_canvas_el.getContext('2d');

			ctx.clearRect(0, 0, this.main_canvas_el.width, this.main_canvas_el.height);

			// draw the image to label

			if (this.image_loaded) {
				ctx.drawImage(this.source_image, 0, 0, this.main_canvas_width, this.main_canvas_height);
			} else {
				ctx.fillStyle = this.color_main_canvas;
				ctx.fillRect(0, 0, this.main_canvas_width, this.main_canvas_height);
			}

			// draw cursor lines

			if (this.is_hovering()) {
				ctx.lineWidth = 1;
				ctx.strokeStyle = this.color_cursor_lines;

				ctx.beginPath();
				ctx.moveTo(this.cursorx, 0);
				ctx.lineTo(this.cursorx, this.main_canvas_height);
				ctx.stroke();

				ctx.beginPath();
				ctx.moveTo(0, this.cursory);
				ctx.lineTo(this.main_canvas_width, this.cursory);
				ctx.stroke();
			}

			// draw existing bounding boxes
			
			var selected = this.get_selected_object();

			for (var obj_id=0; obj_id<this.annotations.length; obj_id++) {

				var obj = this.annotations[obj_id];
				var selectedObj = (selected == obj_id);

				var w = obj.bbox.bmax.x - obj.bbox.bmin.x;
				var h = obj.bbox.bmax.y - obj.bbox.bmin.y;

				// highlight the selected box
				if (selectedObj) {
					ctx.lineWidth = 3;
					ctx.strokeStyle = this.color_highlight_box_outline;
					ctx.fillStyle = this.color_highlight_box_fill;
					ctx.fillRect(obj.bbox.bmin.x, obj.bbox.bmin.y, w, h);
				} else {
					ctx.lineWidth = 2;
					ctx.strokeStyle = this.color_box_outline;
				}

				ctx.strokeRect(obj.bbox.bmin.x, obj.bbox.bmin.y, w, h);

				// draw dots indicating all the extreme points (if there are extreme points)
				if (this.show_extreme_points && obj.extreme_points !== undefined)  {
					var full_circle_angle = 2 * Math.PI;
					ctx.fillStyle = this.color_extreme_point_fill;
					for (var i=0; i<4; i++) {
						ctx.beginPath();
	      				ctx.arc(obj.extremePoints[i].x, obj.extremePoints[i].y, this.extreme_point_radius, 0, full_circle_angle, false);
				        ctx.fill();
					}
				}	
			}

			// render the "in-progress" points (the current partial bounding box)

			if (this.inProgressPoints.length > 0) {

				ctx.lineWidth = 1;
				ctx.strokeStyle = this.color_in_progress_box_outline; 

				if (this.is_mode_extreme_bbox()) {
					this.draw_inprogress_extreme_bbox(ctx);
				} else if (this.is_mode_regular_bbox()) {
					this.draw_inprogress_regular_bbox(ctx);
				}
			}

			// render the "zoomed view"

			if (this.zoom_view_enabled()) {
				this.render_zoom_view();
			}
		}

		handle_image_load = event => {
			console.log("KLabeler: Image loaded.");
			this.image_loaded = true;
			this.render();
		}

		handle_canvas_mousemove = event => {
			this.set_cursor_position(event.offsetX, event.offsetY);
			this.render();
		}

		handle_canvas_mouseover = event => {
			this.set_cursor_position(event.offsetX, event.offsetY);		
			this.render();
		}

		handle_canvas_mouseout = event => {
			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;
			this.render();
		}

		handle_keydown = event => {
			//console.log("KeyDown: " + event.keyCode);

			if (event.keyCode == 32) {
				this.spaceKeyDown = true;
			} else if (event.keyCode == 16) {
				this.shiftKeyDown = true;
			}
		}

		handle_keyup = event => {
			//console.log("KeyUp: " + event.keyCode);

			if (event.keyCode == 32) {
				this.spaceKeyDown = false;
			} else if (event.keyCode == 16) {
				this.shiftKeyDown = false;
			} else if (event.keyCode == 8) {
				this.delete_box();
			}
		}

		handle_canvas_click = event => {

			this.set_cursor_position(event.offsetX, event.offsetY);

			var p = new Point2D(this.cursorx, this.cursory);
			this.inProgressPoints.push(p);

			console.log("KLabeler: Click at x=" + p.x + ", y=" + p.y + " point " + this.inProgressPoints.length);

			if (this.is_mode_extreme_bbox() && this.inProgressPoints.length == 4) {

				// validate box.  Discard box if this set of for extreme points is not a valid set of extreme points
				if (!BBox2D.valid_extreme_points(this.inProgressPoints)) {
					alert("Points clicked are not valid extreme points. Discarding box.");
					this.inProgressPoints = [];
					this.render();
					return;
				}

				var newBBox = BBox2D.extremePointsToBBox(this.inProgressPoints);
				var newAnnotation = new Annotation(newBBox, this.inProgressPoints);

				this.annotations.push(newAnnotation);

				console.log("KLabeler: New box: x=[" + newBBox.bmin.x + ", " + newBBox.bmax.y + "], y=[" + newBBox.bmin.y + ", " + newBBox.bmax.y + "]");
				console.log("KLabeler: There are now " + this.annotations.length + " box(es).");

				this.inProgressPoints = [];

			} else if (this.is_mode_regular_bbox() && this.inProgressPoints.length == 2) {

				// validate box.  Discard any empty boxes.
				if (this.inProgressPoints[0].x == this.inProgressPoints[1].x &&
					this.inProgressPoints[0].y == this.inProgressPoints[1].y) {
					alert("Empty bbox. Discarding box.");
					this.inProgressPoints = [];
					this.render();
					return;
				}

				var newBBox = BBox2D.twoPointsToBBox(this.inProgressPoints);
				var newAnnotation = new Annotation(newBBox);
				this.annotations.push(newAnnotation);

				console.log("KLabeler: New box: x=[" + newBBox.bmin.x + ", " + newBBox.bmax.y + "], y=[" + newBBox.bmin.y + ", " + newBBox.bmax.y + "]");
				console.log("KLabeler: There are now " + this.annotations.length + " box(es).");

				this.inProgressPoints = [];
			}

			this.render();

			if (this.play_audio)
				this.play_click_audio();
		}

		init(main_canvas_el, zoom_canvas_id) {

			console.log("Klabeler: initializing.");

			this.main_canvas_el = main_canvas_el;
			this.main_canvas_width = this.main_canvas_el.width;
			this.main_canvas_height = this.main_canvas_el.height;
			this.main_canvas_el.addEventListener("mousemove", this.handle_canvas_mousemove, false);
			this.main_canvas_el.addEventListener("click", this.handle_canvas_click, false);
			this.main_canvas_el.addEventListener("mouseover", this.handle_canvas_mouseover, false);
			this.main_canvas_el.addEventListener("mouseout", this.handle_canvas_mouseout, false);
			//this.main_canvas_el.addEventListener("keydown", this.handle_canvas_keydown, false);
			//this.main_canvas_el.addEventListener("keyup", this.handle_canvas_keyup, false);

			this.zoom_canvas_el = zoom_canvas_id;

			if (this.zoom_view_enabled()) {
				this.zoom_canvas_width = this.zoom_canvas_el.width;
				this.zoom_canvas_height = this.zoom_canvas_el.height;
			}

			this.source_image.onload = this.handle_image_load;

			this.audio_click_sound = new Audio("media/click_sound2.mp3");
			this.audio_box_done_sound = new Audio("media/click_sound3.mp3");

		}
	}

	var main_canvas_id = 'main_canvas';
	var zoom_canvas_id = 'zoom_canvas';
	var labeler = new ImageLabeler;

	function handle_onload() {

		var main_canvas = document.getElementById(main_canvas_id);
		var zoom_canvas = document.getElementById(zoom_canvas_id);
		labeler.init(main_canvas, zoom_canvas);
		labeler.set_image("media/testimage.jpg");
		labeler.set_zoom_factor(8);

		var button = document.getElementById("toggle_pt_viz_button");
		button.toggle_status = true;
		labeler.set_extreme_points_viz(button.toggle_status);

		button = document.getElementById("toggle_sound_button");
		button.toggle_status = true;
		labeler.set_play_audio(button.toggle_status);

		// HACK(kayvonf): intercept all key events and send them to the labeler
		// There's likely a much better way to do this.
		// The problem is that the labeler canvas needs to have focus in order to accept key events.
		// I'm not certain I want to do that right now.
		window.addEventListener("keydown", function(e) {
			e.preventDefault();
			labeler.handle_keydown(e);
		});

		window.addEventListener("keyup", function(e) {
			e.preventDefault();
			labeler.handle_keyup(e);
		});


	}

	function clear_boxes() {
		labeler.clear_boxes();
	}

	function toggle_extreme_points() {
		var button = document.getElementById("toggle_pt_viz_button");
		var new_status = !button.toggle_status;
		labeler.set_extreme_points_viz(new_status);
		button.toggle_status = new_status;

		if (new_status == false) {
			button.innerHTML = 'Show Extreme Points';
		} else {
			button.innerHTML = 'Hide Extreme Points';
		}
	}

	function toggle_sound() {
		var button = document.getElementById("toggle_sound_button");
		var new_status = !button.toggle_status;
		labeler.set_play_audio(new_status);
		button.toggle_status = new_status;

		if (new_status == false) {
			button.innerHTML = 'Turn Sound On';
		} else {
			button.innerHTML = 'Turn Sound Off';
		}		
	}

</script>
</head>
<body onload="handle_onload()">

<div id="labeled_div">
	<canvas id="main_canvas" width="960" height="540" style="border: 8px solid #c0c0c0;" ></canvas>
	<canvas id="zoom_canvas" width="270" height="270" style="border: 8px solid #c0c0c0;"></canvas>
</div>

<div>
	<button id="clear_button" type="button" onclick="clear_boxes()">Clear Boxes</button>
	<button id="toggle_pt_viz_button" type="button" onclick="toggle_extreme_points()">Hide Extreme Points</button>
	<button id="toggle_sound_button" type="button" onclick="toggle_sound()">Turn Sound On</button>
</div>

<p>Click four times to draw a box.  (Use the <a href="https://arxiv.org/abs/1708.02750">extreme clicking</a> technique: leftmost, topmost, rightmost, bottommost)</p>
<p>Hover over a box to select it. Press DEL to delete the selected box. (Selection picks the smallest area box containing the cursor.)</p>

</body>
</html>