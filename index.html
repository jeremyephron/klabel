<!DOCTYPE html>
<html>
<head>
	<title>KLabel Test</title>
<script>

	/*
		TODO list:

		* zoom view
		* delete individual bbox
		* extract bbox data (including extreme points)
		* move to normalized coordinates
		* support multiple images
		* sound
	*/

	class Point2D {

		constructor(x, y) {
			//if (x===undefined) // parameter was omitted in call
        	//	x = 0.0;
        	//if (y===undefined) // parameter was omitted in call
        	//	y = 0.0;

			this.x = x;
			this.y = y;
		}
	}

	class ObjInstance {
		constructor(bbox, extremePoints) {
			this.bbox = bbox;
			this.extremePoints = extremePoints;
		}
	}

	class BBox2D {
		constructor(startx, starty, width, height) {
			this.bmin = new Point2D(startx, starty);
			this.bmax = new Point2D(this.bmin.x + width, this.bmin.y + height);
		}

		isEmpty() {
			return (this.bmin.x >= this.bmax.y || this.bmin.y >= this.bmax.y);
		}

		set(startx, starty, width, height) {
			this.bmin.x = startx;
			this.bmin.y = starty;
			this.bmax.x = this.bmin.x + width;
			this.bmax.y = this.bmin.y + height;
		}

		inside(x, y) {
			if (x >= this.bmin.x && x <= this.bmax.x &&
				y >= this.bmin.y && y <= this.bmax.y)
				return true;
			else
				return false;
		}

		static extremePointsToBBox(pts) {

			// pts[0] = left extreme
			// pts[1] = top extreme
			// pts[2] = right extreme
			// pts[3] = bottom extreme

			var startx = pts[0].x;
			var starty = pts[1].y;
			var endx = pts[2].x;
			var endy = pts[3].y;
			var b = new BBox2D(startx, starty, endx - startx, endy - starty);
			return b;
		}

		static valid_extreme_points(pts) {
			if (pts[0].x > pts[1].x ||
				pts[0].x > pts[2].x ||
				pts[0].x > pts[3].x)
				return false;
			if (pts[1].y > pts[1].y ||
				pts[1].y > pts[2].y ||
				pts[1].y > pts[3].y)
				return false;
			if (pts[2].x < pts[1].x ||
				pts[2].x < pts[2].x ||
				pts[2].x < pts[3].x)
				return false;
			if (pts[3].y < pts[1].y ||
				pts[3].y < pts[2].y ||
				pts[3].y < pts[3].y)
				return false;
			return true;
		}
	}

	class ImageLabeler {

		constructor() {

			this.main_canvas_el = null;
			this.main_canvas_width = 0;
			this.main_canvas_height = 0;
			this.zoom_canvas_el = null;
			this.zoom_canvas_width = 0;
			this.zoom_canvas_height = 0;

			this.zoom_factor = 4;
			this.show_extreme_points = true;

			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;

			this.image_loaded = false;
			this.source_image = new Image;

			this.objInstances = []
			this.inProgressPoints = [];

			// colors
			this.color_main_canvas = '#c0c0c0';
			this.color_zoom_canvas = '#404040';
			this.color_cursor_lines = 'rgba(0,255,255,0.5)';
			this.color_in_progress_box_outline = 'rgba(255,255,255,0.75)';
			this.color_box_outline = 'rgba(255,200,0,0.75)';
			this.color_highlight_box_outline = 'rgba(255,200,100,1.0)';
			this.color_highlight_box_fill = 'rgba(255,200,150,0.2)';
			this.color_extreme_point_fill = '#ffff00';

			this.extreme_point_radius = 2;
		}

		// Clamp the cursor to the image dimensions so that clicks and bounding boxes
		// are always on the image.
		set_cursor_position(x,y) {
			this.cursorx = Math.min(this.main_canvas_width-1, Math.max(0, x));
			this.cursory = Math.min(this.main_canvas_height-1, Math.max(0, y));	
		}

		handle_image_load = event => {
			console.log("KLabeler: Image loaded.");
			this.image_loaded = true;
			this.render();
		}

		handle_canvas_mousemove = event => {
			this.set_cursor_position(event.offsetX, event.offsetY);
			this.render();
		}

		handle_canvas_mouseover = event => {
			this.set_cursor_position(event.offsetX, event.offsetY);		
			this.render();
		}

		handle_canvas_mouseout = event => {
			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;
			this.render();
		}

		handle_canvas_click = event => {

			this.set_cursor_position(event.offsetX, event.offsetY);

			var p = new Point2D(this.cursorx, this.cursory);
			this.inProgressPoints.push(p);

			console.log("Click at x=" + p.x + ", y=" + p.y + " point " + this.inProgressPoints.length);

			if (this.inProgressPoints.length == 4) {

				if (!BBox2D.valid_extreme_points(this.inProgressPoints)) {
					alert("Points clicked are not valid extreme points. Discarding box.");
					this.inProgressPoints = [];
					this.render();
					return;
				}

				var newBBox = BBox2D.extremePointsToBBox(this.inProgressPoints);
				var newObj = new ObjInstance(newBBox, this.inProgressPoints);

				this.objInstances.push(newObj);

				var str = "New box: x=[" + newBBox.bmin.x + ", " + newBBox.bmax.y + "], y=[" + newBBox.bmin.y + ", " + newBBox.bmax.y + "]"
				console.log(str);
				console.log("There are now " + this.objInstances.length + " boxes.");

				this.inProgressPoints = [];
			}

			this.render();
		}

		set_zoom_factor(zoom) {
			this.zoom_factor = zoom;
			this.render();
		}

		set_extreme_points_viz(status) {
			this.show_extreme_points = status;
			this.render();
		}

		set_image(url) {
			// initiate loading of the image to label
			console.log('KLabeler: Starting image load: ' + url);
			this.source_image.src = url;
		}

		clear_boxes() {
			this.inProgressPoints = [];
			this.objInstances = [];
			this.render();
		}

		isHovering() {
			return (this.cursorx >= 0 && this.cursory >= 0);
		}

		zoomViewEnabled() {
			return !(this.zoom_canvas_el === undefined);
		}

		render() {
			var ctx = this.main_canvas_el.getContext('2d');

			ctx.clearRect(0, 0, this.main_canvas_el.width, this.main_canvas_el.height);

			if (this.image_loaded) {
				ctx.drawImage(this.source_image, 0, 0, this.main_canvas_width, this.main_canvas_height);
			} else {
				ctx.fillStyle = this.color_main_canvas;
				ctx.fillRect(0, 0, this.main_canvas_width, this.main_canvas_height);
			}

			// draw cursor lines

			if (this.isHovering()) {
				ctx.lineWidth = 1;
				ctx.strokeStyle = this.color_cursor_lines;

				ctx.beginPath();
				ctx.moveTo(this.cursorx, 0);
				ctx.lineTo(this.cursorx, this.main_canvas_height);
				ctx.stroke();

				ctx.beginPath();
				ctx.moveTo(0, this.cursory);
				ctx.lineTo(this.main_canvas_width, this.cursory);
				ctx.stroke();
			}

			// draw bounding boxes

			ctx.lineWidth = 2;
			
			this.objInstances.forEach( obj => {

				var b = obj.bbox;
				var cursorInsideBox = b.inside(this.cursorx, this.cursory);

				// highlight boxes if cursor is inside the box
				if (cursorInsideBox) {
					ctx.strokeStyle = this.color_highlight_box_outline;
					ctx.fillStyle = this.color_highlight_box_fill;
				} else {
					ctx.strokeStyle = this.color_box_outline;
				}

				var w = b.bmax.x - b.bmin.x;
				var h = b.bmax.y - b.bmin.y;
				if (cursorInsideBox)
					ctx.fillRect(b.bmin.x, b.bmin.y, w, h);
				ctx.strokeRect(b.bmin.x, b.bmin.y, w, h);

				// draw dots at all the extreme points
				if (this.show_extreme_points) {
					var full_circle_angle = 2 * Math.PI;
					ctx.fillStyle = this.color_extreme_point_fill;
					for (var i=0; i<4; i++) {
						ctx.beginPath();
	      				ctx.arc(obj.extremePoints[i].x, obj.extremePoints[i].y, this.extreme_point_radius, 0, full_circle_angle, false);
				        ctx.fill();
					}
				}	
			});

			// render the "in-progress" points (the current partial bounding box)

			if (this.inProgressPoints.length > 0) {

				ctx.lineWidth = 1;
				ctx.strokeStyle = this.color_in_progress_box_outline; 

				// draw the points we've locked down
				ctx.beginPath();
				ctx.moveTo(this.inProgressPoints[0].x, this.inProgressPoints[0].y);
				for (var i=1; i<this.inProgressPoints.length; i++) {
					var cornerx = 0;
					var cornery = 0;
					if (i == 1) {
						cornerx = this.inProgressPoints[0].x;
						cornery = this.inProgressPoints[1].y;
					} else if (i == 2) {
						cornerx = this.inProgressPoints[2].x;
						cornery = this.inProgressPoints[1].y;
					} else if (i == 3) {
						cornerx = this.inProgressPoints[0].x;
						cornery = this.inProgressPoints[3].y;
					}
					ctx.lineTo(cornerx, cornery);
				}

				// now draw the tentative point
				if (this.isHovering()) {
					if (this.inProgressPoints.length == 1) {
						ctx.lineTo(this.inProgressPoints[0].x, this.cursory);		
						ctx.lineTo(this.cursorx, this.cursory);
					} else if (this.inProgressPoints.length == 2) {
						ctx.lineTo(this.cursorx, this.inProgressPoints[1].y);
						ctx.lineTo(this.cursorx, this.cursory);
					} else if (this.inProgressPoints.length == 3) {
						ctx.lineTo(this.inProgressPoints[2].x, this.cursory);
						// extrapolation of rest of box
						ctx.lineTo(this.inProgressPoints[0].x, this.cursory);
						ctx.lineTo(this.inProgressPoints[0].x, this.inProgressPoints[0].y);
					}
				}
				ctx.stroke();

				// draw dots at all the extreme points
				var full_circle_angle = 2 * Math.PI;
				ctx.fillStyle = this.color_extreme_point_fill;
				for (var i=0; i<this.inProgressPoints.length; i++) {
					ctx.beginPath();
      				ctx.arc(this.inProgressPoints[i].x, this.inProgressPoints[i].y, this.extreme_point_radius, 0, full_circle_angle, false);
			        ctx.fill();
				}	

			}

			if (this.zoomViewEnabled()) {

				// now render zoom canvas view
				var ctx = this.zoom_canvas_el.getContext('2d');
				ctx.clearRect(0, 0, this.zoom_canvas_el.width, this.zoom_canvas_el.height);

				ctx.fillStyle = this.color_zoom_canvas;
				ctx.fillRect(0, 0, this.zoom_canvas_width, this.zoom_canvas_height);

				if (this.isHovering()) {

					// draw zoomed view of image
					var sw = this.zoom_canvas_width / this.zoom_factor;
					var sh = this.zoom_canvas_height / this.zoom_factor;
					var sx = this.source_image.width * this.cursorx / this.main_canvas_width - (sw / 2);
					var sy = this.source_image.height * this.cursory / this.main_canvas_height - (sh / 2);

					ctx.imageSmoothingEnabled = false;
					ctx.drawImage(this.source_image, sx, sy, sw, sh, 0, 0, this.zoom_canvas_width, this.zoom_canvas_height);

					// draw zoomed in cursor 
					ctx.lineWidth = this.zoom_factor;
					ctx.strokeStyle = this.color_cursor_lines;

					// lines with greater that one pixel thickness are "centered" about the specified endpoints
					// offset the line so that that (potentially) thick line is aligned with the pixels in the visualization
					var offsetx = ctx.lineWidth / 2;
					var offsety = ctx.lineWidth / 2;

					ctx.beginPath();
					ctx.moveTo(this.zoom_canvas_width/2 - offsetx, 0);
					ctx.lineTo(this.zoom_canvas_width/2 - offsetx, this.zoom_canvas_height);
					ctx.stroke();

					ctx.beginPath();
					ctx.moveTo(0, this.zoom_canvas_height/2 - offsety);
					ctx.lineTo(this.zoom_canvas_width, this.zoom_canvas_height/2  - offsety);
					ctx.stroke();
				}
			}
		}

		init(main_canvas_el, zoom_canvas_id) {

			console.log("Klabeler: initializing.");

			this.main_canvas_el = main_canvas_el;
			this.main_canvas_width = this.main_canvas_el.width;
			this.main_canvas_height = this.main_canvas_el.height;
			this.main_canvas_el.addEventListener("mousemove", this.handle_canvas_mousemove, false);
			this.main_canvas_el.addEventListener("click", this.handle_canvas_click, false);
			this.main_canvas_el.addEventListener("mouseover", this.handle_canvas_mouseover, false);
			this.main_canvas_el.addEventListener("mouseout", this.handle_canvas_mouseout, false);

			this.zoom_canvas_el = zoom_canvas_id;

			if (this.zoomViewEnabled()) {
				this.zoom_canvas_width = this.zoom_canvas_el.width;
				this.zoom_canvas_height = this.zoom_canvas_el.height;
			}

			//this.source_image.addEventListener("onload", this.handle_image_load, false);
			this.source_image.onload = this.handle_image_load;

			var ctx = this.main_canvas_el.getContext('2d');
		}
	}

	var main_canvas_id = 'main_canvas';
	var zoom_canvas_id = 'zoom_canvas';
	var labeler = new ImageLabeler;

	function handle_onload() {
		var main_canvas = document.getElementById(main_canvas_id);
		var zoom_canvas = document.getElementById(zoom_canvas_id);
		labeler.init(main_canvas, zoom_canvas);
		labeler.set_image("testimage.jpg");
		labeler.set_zoom_factor(16);

		var button = document.getElementById("toggle_pt_viz_button");
		button.toggle_status = true;
	}

	function clear_boxes() {
		labeler.clear_boxes();
	}

	function toggle_extreme_points() {
		var button = document.getElementById("toggle_pt_viz_button");
		var new_status = !button.toggle_status;
		labeler.set_extreme_points_viz(new_status);
		button.toggle_status = new_status;

		if (new_status == false) {
			button.innnerHTML = 'Show Extreme Points';
		} else {
			button.innnerHTML = 'Hide Extreme Points';
		}
	}

</script>
</head>
<body onload="handle_onload()">

<div>
	<canvas id="main_canvas" width="960" height="540" style="border: 8px solid #c0c0c0;"></canvas>
	<canvas id="zoom_canvas" width="512" height="270" style="border: 8px solid #c0c0c0;"></canvas>
</div>

<div>
	<button id="clear_button" type="button" onclick="clear_boxes()">Clear Boxes</button>
	<button id="toggle_pt_viz_button" type="button" onclick="toggle_extreme_points()">Hide Extreme Points</button>
</div>

</body>
</html>