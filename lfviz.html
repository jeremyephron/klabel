<!DOCTYPE html>
<html>
<head>
	<title>Labeling Function Viz</title>
<style>
	body {
		font-family: Helvetica, Arial, sans-seris;
		font-size: 10pt;
		color: #a0a0a0;
		background: #ffffff;
	}

	body a {
		color: #d0d0d0;
	}

	.bold_text {
		font-weight: bold;
	}

</style>

<script src="kmath.js"></script>
<script>

	class KLFViz {

		static get DATAPOINT_TYPE_NONE() { return 0; }
		static get DATAPOINT_TYPE_TEXT() { return 1; }
		static get DATAPOINT_TYPE_IMAGE() { return 2; }

		constructor() {
			this.main_canvas_el = null;
			this.preview_main_el = null;
			this.cached_canvas_image = null;

			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;

			this.data_matrix = null;
			this.num_rows = 0;
			this.num_lf = 0;

			// color constants
			this.color_main_canvas = '#e0e0e0';
			this.color_lf_positive = '#67bf5c';
			this.color_lf_negative = '#ed665d';
			this.color_lf_abstain = '#a2a2a2';
			this.color_highlight_box_outline = 'rgba(255, 255, 255, 0.5)';

			// layout parameters
			this.display_el_width = 8;
			this.display_el_height = 8;
			this.display_col_sep = 8;

		}

		// true if the mouse is hovering over the canvas
		is_hovering() {
			return (this.cursorx >= 0 && this.cursory >= 0);
		}

		// Clamp the cursor to the image dimensions so that clicks,
		// and (resulting bounding boxes) are always within the image
		set_canvas_cursor_position(x,y) {
			this.cursorx = clamp(x, 0, this.main_canvas_el.width);
			this.cursory = clamp(y, 0, this.main_canvas_el.height);	
		}

		get_selected_datapoint() {

			// first get the cursor's row
			var row = Math.floor(this.cursory / this.display_el_height);

			// then get the cursor's column
			var spaced_col_width = this.display_el_width*this.num_lf + this.display_col_sep;
			var col = Math.floor(this.cursorx / spaced_col_width);

			// compute datapoint index
			var rows_per_col = Math.floor(this.main_canvas_el.height / this.display_el_height);
			return col * rows_per_col + row;
		}

		render_cached_viz() {

			var ctx = this.main_canvas_el.getContext('2d');

			ctx.fillStyle = this.color_main_canvas;
			ctx.fillRect(0, 0, this.main_canvas_el.width, this.main_canvas_el.height);

			var rows_per_col = Math.floor(this.main_canvas_el.height / this.display_el_height);
			var num_cols = Math.floor((this.num_rows + rows_per_col - 1) / rows_per_col); 

			for (var col=0; col<num_cols; col++) {

				var start_row = col * rows_per_col;
				var end_row = Math.min(start_row + rows_per_col, this.num_rows);
				var rows_in_this_col = end_row - start_row;

				// now draw a column of data points
				for (var i=0; i<rows_in_this_col; i++) {
					var start_y = i*this.display_el_height;

					for (var j=0; j<this.num_lf; j++) {
						var idx = (start_row + i)*this.num_lf + j;

						var el_color = this.color_lf_abstain;
						if (this.data_matrix[idx] == 1)
							el_color = this.color_lf_positive;
						else if (this.data_matrix[idx] == -1)
							el_color = this.color_lf_negative;

						var start_x = col * (this.display_el_width * this.num_lf + this.display_col_sep) + j*this.display_el_width;
						ctx.fillStyle = el_color;
						ctx.fillRect(start_x, start_y, this.display_el_width, this.display_el_height);
					}
				}
			}

			this.cached_canvas_image = ctx.getImageData(0, 0, this.main_canvas_el.width, this.main_canvas_el.height);

		}

		render() {

			var ctx = this.main_canvas_el.getContext('2d');

			ctx.fillStyle = this.color_main_canvas;
			ctx.fillRect(0, 0, this.main_canvas_el.width, this.main_canvas_el.height);

			// draw the cached image previously rendered
			ctx.putImageData(this.cached_canvas_image, 0, 0);

			// check to see if cursor is hovering over any datapoint row.
			// if so, highlight it
			if (this.is_hovering()) {

				var idx = this.get_selected_datapoint();
				var rows_per_col = Math.floor(this.main_canvas_el.height / this.display_el_height);
				var row = idx % rows_per_col;
				var col = Math.floor(idx / rows_per_col);

				// draw the highlight
				if (idx < this.num_rows) {

					var spaced_col_width = this.display_el_width*this.num_lf + this.display_col_sep;

					ctx.lineWidth = 2;
					ctx.strokeStyle = this.color_highlight_box_outline;

					for (var i=0; i<this.num_lf; i++) {
		
						//ctx.strokeRect(col*spaced_col_width, row*this.display_el_height,
					    //		   this.display_el_width*this.num_lf, this.display_el_height);
						ctx.strokeRect(col*spaced_col_width + this.display_el_width*i, row*this.display_el_height,
					    		   this.display_el_width, this.display_el_height);

					}
				}
			}
		}

		update_preview() {
			if (this.is_hovering()) {
				var idx = this.get_selected_datapoint();
				if (idx < this.num_rows) {
					var str = "<p>Datapoint: " + idx + " of " + this.num_rows + "<p/>";
					if (this.datapoint_type == KLFViz.DATAPOINT_TYPE_TEXT)
						str += "<p>" + this.datapoints[idx] + "</p>";
					else if (this.datapoint_type == KLFViz.DATAPOINT_TYPE_IMAGE)
						str += "<p><img src=\"" + this.datapoints[idx] + "\" width=\"" +
                               this.preview_div_el.clientWidth + "\" /></p>";

                    this.preview_div_el.innerHTML = str;
				}
				else {
					this.preview_div_el.innerHTML = "";
				}
			}
		}

		load_data(num_rows, num_lf, matrix, datapoint_type=KLFViz.DATAPOINT_TYPE_NONE, datapoints=[]) {
			this.num_rows = num_rows;
			this.num_lf = num_lf;
			this.data_matrix = matrix;

			this.datapoint_type = datapoint_type;
			this.datapoints = datapoints;

			console.log("KLFViz: loading data (num rows=" + this.num_rows + ", num lf=" + this.num_lf + ")" +
			       	    " datapoint_type=" + this.datapoint_type);

			this.render_cached_viz();
			this.render();
		}

		handle_canvas_mousemove = event => {
			this.set_canvas_cursor_position(event.offsetX, event.offsetY);
			this.render();
			this.update_preview();
		}

		handle_canvas_mouseover = event => {
			this.set_canvas_cursor_position(event.offsetX, event.offsetY);		
			this.render();
			this.update_preview();
		}

		handle_canvas_mouseout = event => {
			this.cursorx = Number.MIN_SAFE_INTEGER;
			this.cursory = Number.MIN_SAFE_INTEGER;
			this.render();
			this.update_preview();
		}

		init(main_canvas_el, preview_div_el) {

			console.log("KLFViz: initializing...");
			this.main_canvas_el = main_canvas_el;

			this.main_canvas_el.addEventListener("mousemove", this.handle_canvas_mousemove, false);
			this.main_canvas_el.addEventListener("mouseover", this.handle_canvas_mouseover, false);
			this.main_canvas_el.addEventListener("mouseout",  this.handle_canvas_mouseout,  false);

			this.preview_div_el = preview_div_el;

			this.render_cached_viz();
			this.render();
		}
	}

	var main_canvas_id = 'main_canvas';   // this is the DOM canvas element 
	var preview_div_id = 'preview_div';   // this is the DOM canvas element 
	var lfviz = new KLFViz;
	
	var num_rows = 1024;
	var num_lf = 5;

	function create_dummy_text_data(num_rows, num_lf, matrix, datapoints) {

		// fill in dummy data
		for (var i = 0; i<num_rows; i++) {
			for (var j=0; j<num_lf; j++) {

				var x = Math.random();

				if (x < 1.0/5.0)
					matrix[i*num_lf + j] = 1;
				else if (x < 2.0/5.0)
					matrix[i*num_lf + j] = -1;
				else
					matrix[i*num_lf + j] = 0;
			}

			datapoints.push("This is the text string associated with datapoint " + i + " that the labeling functions were executed on.  LFViz will display the text on hover.");
		}
	}

	function create_dummy_image_data(num_rows, num_lf, matrix, datapoints) {
		
		// fill in dummy data
		for (var i = 0; i<num_rows; i++) {
			for (var j=0; j<num_lf; j++) {

				var x = Math.random();

				if (x < 1.0/5.0)
					matrix[i*num_lf + j] = 1;
				else if (x < 2.0/5.0)
					matrix[i*num_lf + j] = -1;
				else
					matrix[i*num_lf + j] = 0;
			}

			datapoints.push("media/image_0" + (i % 8) + ".jpg");
		}		
	}

	function handle_create_dummy_text() {
		var matrix = [];
		var datapoints = [];
		create_dummy_text_data(num_rows, num_lf, matrix, datapoints);		
		lfviz.load_data(num_rows, num_lf, matrix, KLFViz.DATAPOINT_TYPE_TEXT, datapoints);
	}

	function handle_create_dummy_images() {
		var matrix = [];
		var datapoints = [];
		create_dummy_image_data(num_rows, num_lf, matrix, datapoints);
		lfviz.load_data(num_rows, num_lf, matrix, KLFViz.DATAPOINT_TYPE_IMAGE, datapoints);
	}

	function handle_onload() {

		var matrix = [];
		var datapoints = [];
		create_dummy_image_data(num_rows, num_lf, matrix, datapoints);

		var main_canvas = document.getElementById(main_canvas_id);
		var preview_div = document.getElementById(preview_div_id);

		lfviz.init(main_canvas, preview_div);
		lfviz.load_data(num_rows, num_lf, matrix, KLFViz.DATAPOINT_TYPE_IMAGE, datapoints);
	}

</script>
</head>

<body onload="handle_onload()">

<div id="labeled_div">
	<canvas id="main_canvas" width="960" height="500" style="border: 1px solid #c0c0c0; display: block; float: left;" ></canvas>
	<div id="preview_div" style="padding-left: 5px; width: 256px; height: 500px; float: left;">&nbsp;</div>
</div>

<div style="clear: both;">
	<button id="dummy_text_button" type="button" onclick="handle_create_dummy_text()">Create Dummy Text Data</button>
	<button id="dummy_image_button" type="button" onclick="handle_create_dummy_images()">Create Dummy Image Data</button>
</div>

<p>
<div>Green - positive vote</div>
<div>Red - positive vote</div>
<div>Gray - abstain</div>
</p>
<p>Hover over a row to see the data point.</p>
<!-- 
<div>Highlight data points where 
	<select id="select_lf" onchange="">
       <option value="lf_all">all labels funcs</option>
       <option value="lf_any">any labeling func</option>
    </select>
    <select id="select_lf_status" onchange="">
       <option value="positive">vote positive</option>
       <option value="negative">vote negative</option>
       <option value="abstain">abstain</option>
       <option value="abstain">disagrees</option>
    </select>
    .
</div>
-->

</body>
</html>