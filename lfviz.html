<!DOCTYPE html>
<html>
<head>
	<title>Labeling Function Viz</title>

<style>

	body {
		font-family: Helvetica, Arial, sans-seris;
		font-size: 10pt;
		color: #808080;
		background: #ffffff;
	}

	body a {
		color: #d0d0d0;
	}

	.bold_text {
		font-weight: bold;
	}

	.red_highlight {
		color: #ff0000;
	}

</style>

<script src="kmath.js"></script>
<script src="klfviz.js"></script>

<script>

	// hacky enum
	var LF_OUTPUT_POSITIVE = 1
	var LF_OUTPUT_NEGATIVE = -1
	var LF_OUTPUT_ABSTAIN = 0;
	var LF_OUTPUT_DISAGREE = -2
     
	var lfviz = new LFViz;

	///////////////////////////////////////////////////////////
	// input data (from the debug dump) 
	///////////////////////////////////////////////////////////

	var INPUT_BASE_URL = 'lfviz_assets/'
	var DUMP_NAME = "backhand"

	var num_train = 0;
	var num_val = 0;
	var num_lf = 0;

	// human-readable names for all the labeling functions
	var lf_names = []

	// the source data: text strings (if text), or an image url
	var datapoint_type = LFViz.DATAPOINT_TYPE_IMAGE;
	var datapoints = []
	
	// table of labeling function outputs (pre and post extension)
	var lf_matrix_noext = []
	var lf_matrix_ext = []
	
	// label model output (pre and post extension)
	var prob_labels_noext  = []
	var prob_labels_ext  = []

	// ground truth labels
	var ground_truth_labels = []

	///////////////////////////////////////////////////////////
	// viz application state
	///////////////////////////////////////////////////////////

	var use_noext_data = true;

	// This mask denoting the rows that should be rendered in the visualizer
	var row_filter_mask = [];

	// sorting of the rows in the visualizer
	var row_sorting = [];

	var pending_data_load_events = 0;

	// called when the dataset info file has been downloaded
	function handle_info_file_loaded(info) {

		num_lf = info.num_lf;
		num_train = info.num_train;
		num_val = info.num_val;
		dataset_description = info.description;
		lf_names = info.lf_names;

		if (info.datatype == "string")
			datapoint_type = LFViz.DATAPOINT_TYPE_STRING;
		else if (info.datatype == "image_url")
			datapoint_type = LFViz.DATAPOINT_TYPE_IMAGE_URL;
		else 
			datapoint_Type = LFViz.DATAPOINT_TYPE_NONE;
	}

	// called upon completion of a dataset data file download
	function handle_data_load_event() {
		pending_data_load_events--;

		// all data is loaded, we can now take action to load the viz widget
		if (pending_data_load_events == 0)
			handle_data_load_complete();
	}

	// called when all dataset data has been loaded
	// See load_data() for the logic used to initiate all the data load requests
	function handle_data_load_complete() {
		var num_total = num_train + num_val;

		// if the type of the data is an imagte, need to patch up the urls to make
		// them relative to INPUT_BASE_URL
		if (datapoint_type == LFViz.DATAPOINT_TYPE_IMAGE_URL) {
			var temp_datapoints = []
			for (var i=0; i<num_total; i++)
				temp_datapoints.push(INPUT_BASE_URL + datapoints[i]);
			datapoints = temp_datapoints;
		}

		if (!check_data_sanity())
			alert("Data in dump file did not pass sanity check.");

		console.log("Data load complete: train size=" + num_train + ", val size=" + num_val + ", num LFs=" + num_lf);

		// update the filter selection dropdown box to include options for the various labeling functions
		var select_box = document.getElementById("select_lf");
		for (var i=0; i<num_lf; i++) {
			var option = document.createElement("option");
			option.text = lf_names[i];
			select_box.add(option);
		}

		// update the DOM to display stats about the dataset 
		var data_info_el = document.getElementById('data_info');  
		var contents = "<p>";
		contents += "<div>Description: " + dataset_description + "</div>";
		contents += "<div>Num train: " + num_train + "</div>";
		contents += "<div>Num val: " + num_val + "</div>";
		contents += "<div>Num LFs: " + num_lf + "</div>";
		contents += "<div>LF Names: ";
		for (var i=0; i<num_lf; i++) {
			contents += lf_names[i];
			if (i < num_lf-1)
				contents += ", "
		}
		contents += "</p>"
		data_info_el.innerHTML = contents;			

		// communicate data to the viz widget

		var lf_matrix = use_noext_data  ? lf_matrix_noext : lf_matrix_ext;
		var prob_labels = use_noext_data ? prob_labels_noext : prob_labels_ext;

		lfviz.set_data(num_total, num_lf, lf_matrix, prob_labels, ground_truth_labels, datapoint_type, datapoints);
		reset_row_filter_mask();
		handle_sort_change();
	}

	// Entrypoint that initiates logic for loading data from the server via a sequence of async requests 
	//
	// First, the app loads the dataset "info file", which contains a bunch of metadata about the dataset.
	// After the info file has loaded, then the app fires off a collection of various async requests
	// (via Javascript's Fetch API) to get all the associated data files.  
	//
	// See handle_data_load_complete() for the logic that occurs when all data has loaded. 
	function load_data() {

		num_train = 0;
		num_val = 0;
		num_lf = 0;
		datapoint_type = LFViz.DATAPOINT_TYPE_IMAGE;
		lf_names = [];

		lf_matrix_noext = [];
		lf_matrix_ext = [];
  		prob_labels_noext = [];
  		prob_labels_ext = [];
  		ground_truth_labels = []
 		datapoints = [];

 		pending_data_load_events = 6;

		var dump_info_url = INPUT_BASE_URL + DUMP_NAME + '.json';

 		fetch(dump_info_url)
 			.then(function(response) {
 				if (response.status !== 200) {
 					console.log("problem: " + response.status);
 				}
 				return response.json();
			})
			.then(function(data) {

				handle_info_file_loaded(data);

				// now kick off all the individual data file loads
				var prefix = INPUT_BASE_URL + DUMP_NAME;
				var lf_matrix_noext_url = prefix + '_lfmatrix_noext.json';
				var prob_labels_noext_url = prefix + '_prob_labels_noext.json';
				var lf_matrix_ext_url = prefix + '_lfmatrix_ext.json';
				var prob_labels_ext_url = prefix + '_prob_labels_ext.json';
				var datapoints_url = prefix + '_datapoints.json';
				var ground_truth_labels_url = prefix + '_ground_truth_labels.json';

		 		fetch(datapoints_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						datapoints = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching datapoints: ', err);
		 			});

		 		fetch(prob_labels_noext_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						prob_labels_noext = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching LM (noext) output: ', err);
		 			});

		 		fetch(prob_labels_ext_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						prob_labels_ext = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching LM (ext) output: ', err);
		 			});

		 		fetch(lf_matrix_noext_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						lf_matrix_noext = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching LF matrix (noext) data: ', err);
		 			});

		 		fetch(lf_matrix_ext_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						lf_matrix_ext = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching LF matrix (ext) data: ', err);
		 			});

		 		fetch(ground_truth_labels_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						ground_truth_labels = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching ground truth data: ', err);
		 			});

			})
 			.catch(function(err) {
 				console.log('Error fetching dataset info file: ', err);
 			});
	}

	// Check consistency of dataset. Verifies that the size of downloaded
	// data files matches what is reported in the metadata files of the
	// dataset info file.
	function check_data_sanity() {

		var num_total = num_train + num_val;
		var check_passed = true;

		if (lf_names.length != num_lf) {
			console.log("Unexpected number of labeling function names. Expected " + num_lf + ", data has " + lf_names.length);
			check_passed = false;

		} else if (datapoints.length != num_total) {
			console.log("Unexpected number of datapoint values. Expected " + num_total + ", data has " + datapoints.length);		
			check_passed = false;

		} else if (ground_truth_labels.length != num_total) {
			console.log("Unexpected number of ground truth labels. Expected " + num_total + ", data has " + ground_truth_labels.length);
			check_passed = false;

		} else if (lf_matrix_noext.length != num_total * num_lf) {
			console.log("Unexpected number of lf matrix values (noext). Expected " + (num_total * num_lf) + ", data has " + lf_matrix_noext.length);		
			check_passed = false;

		} else if (lf_matrix_ext.length != num_total * num_lf) {
			console.log("Unexpected number of lf matrix values (ext). Expected " + (num_total * num_lf) + ", data has " + lf_matrix_ext.length);		
			check_passed = false;
		
		} else if (prob_labels_ext.length != num_total) {
			console.log("Unexpected number of label model values (ext). Expected " + num_total + ", data has " + label_model_ext.length);		
			check_passed = false;
		
		} else if (prob_labels_noext.length != num_total) {
			console.log("Unexpected number of label model values (noext). Expected " + num_total + ", data has " + label_model_noext.length);		
			check_passed = false;
		}

		return check_passed;
	}

    // HACK(kayvonf): This is a function that filters rows according to a predicate.
    // It's meant to be throwaway code for now.
    // it returns a boolean array that designates which rows should be retained
	function compute_row_filter_mask(lf_function, criteria) {

		row_filter_mask = [];

		var disagree_check = false;
		if (criteria == -2)
			disagree_check = true;

		var num_total = num_train + num_val;

		var lf_matrix = (use_noext_data) ? lf_matrix_noext : lf_matrix_ext;

		//
		// no filter
		//
		if (lf_function == -1) {  		
			for (var i=0; i<num_total; i++) {
				row_filter_mask[i] = true;
			}

		//
		// all LFs match criteria
		//
		} else if (lf_function == -2) {  

			for (var i=0; i<num_total; i++) {
				var idx = i*num_lf;
				row_filter_mask[i] = true;
				for (var j=0; j<num_lf; j++) {
					if (lf_matrix[idx + j] != criteria || lf_matrix[idx+j] == LF_OUTPUT_DISAGREE)
						row_filter_mask[i] = false;
				}
			}

		//
		// all LFs that vote match critera
		//
		} else if (lf_function == -3) { 	

			for (var i=0; i<num_total; i++) {
				var idx = i*num_lf;
				var num_votes = 0;

				row_filter_mask[i] = true;

				for (var j=0; j<num_lf; j++) {
					if (lf_matrix[idx + j] == LF_OUTPUT_ABSTAIN)
						continue;
					
					num_votes++;
					if (lf_matrix[idx + j] != criteria || lf_matrix[idx+j] == LF_OUTPUT_DISAGREE)
						row_filter_mask[i] = false;
				}

				// row shouldn't pass an "all voting LF that..." filter if there are no voting LFs
				if (num_votes == 0)
					row_filter_mask[i] = false;
			}

		//
		// any LFs match criteria
		//
		} else if (lf_function == -4) {

			for (var i=0; i<num_total; i++) {
				var idx = i*num_lf;
				row_filter_mask[i] = false;
				for (var j=0; j<num_lf; j++) {

					if (disagree_check) {
						for (var k=0; k<num_lf; k++) {
							if (j != k && 
								lf_matri_noext[idx+j] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+k] != LF_OUTPUT_ABSTAIN &&
								lf_matrix[idx+j] != lf_matrix[idx+k]) {
								row_filter_mask[i] = true; 
							}
						}

					} else {
						if (lf_matrix[idx + j] == criteria)
							row_filter_mask[i] = true;
					}
				}
			}

		//
		// specific LFs match criteria
 		//
		} else {

			for (var i=0; i<num_total; i++) {
				var idx = i*num_lf;
				row_filter_mask[i] = false;

				if (disagree_check) {
					for (var k=0; k<num_lf; k++) {
						if (lf_function != k &&
							lf_matrix[idx+lf_function] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+k] != LF_OUTPUT_ABSTAIN &&
							lf_matrix[idx+lf_function] != lf_matrix[idx+k]) {
							row_filter_mask[i] = true; 
						}
					}

				} else {
					if (lf_matrix[idx + lf_function] == criteria)
						row_filter_mask[i] = true;
				}
			}

		}
	}

	function reset_row_filter_mask() {
		compute_row_filter_mask(-1, 0);
		lfviz.set_row_filter_mask(row_filter_mask);
	}

	function handle_clear_row_filter_mask() {
		reset_row_filter_mask();
	}

	function handle_change_row_filter_mask() {

		var lf_select = 0;
		var lf_value = 1;
		var select_lf_box = document.getElementById("select_lf");
		var select_value_box = document.getElementById("select_lf_status");

		// which LF's to look at
		if (select_lf_box.value == "lf_all")
			lf_select = -2;
		else if (select_lf_box.value == "lf_all_voting")
			lf_select = -3;
		else if (select_lf_box.value == "lf_any")
			lf_select = -4;
		else {
			for (var i=0; i<num_lf; i++) {
				if (lf_names[i] == select_lf_box.value) {
					lf_select = i;
					break;
				}
			}
		}
		
		// what values are important
		if (select_value_box.value == "positive")
			lf_value = LF_OUTPUT_POSITIVE;
		else if (select_value_box.value == "negative")
			lf_value = LF_OUTPUT_NEGATIVE;
		else if (select_value_box.value == "abstain")
			lf_value = LF_OUTPUT_ABSTAIN;
		else {
			lf_value = LF_OUTPUT_DISAGREE;   // disagrees
		}	

		compute_row_filter_mask(lf_select, lf_value); 
		lfviz.set_row_filter_mask(row_filter_mask);
	}

	function handle_toggle_show_extended() {

		use_noext_data = !use_noext_data;

		var lf_matrix;
		var prob_labels;

		var button = document.getElementById("toggle_extended_button");
		var text = document.getElementById("toggle_extended_text");

		if (use_noext_data) {
			lf_matrix = lf_matrix_noext;
			prob_labels = prob_labels_noext;
			text.innerHTML = 'Showing data BEFORE extension.';
			button.innerHTML = 'Show Extended Data';

		} else {
			lf_matrix = lf_matrix_ext;
			prob_labels = prob_labels_ext;
			text.innerHTML = 'Showing data AFTER extension.';
			button.innerHTML = 'Show Original LF Data';
		}

		// update UI

		// update data in the viz widget
		var num_total = num_train + num_val;
		lfviz.set_data(num_total, num_lf, lf_matrix, prob_labels, ground_truth_labels, datapoint_type, datapoints);

		// recompute masks and sorts since the data input to these operations has changed
		reset_row_filter_mask();
		handle_sort_change();

	}

	// sorting predicate
	function sort_ascending_function(el1, el2) {

		if (el1[1] < el2[1])
			return -1;
		else if (el1[1] > el2[1])
			return 1;
		return 0;
	}
	
	function handle_sort_change() {

		var sort_box = document.getElementById('sort_by_selection');
		var sort_value = sort_box.value;
		console.log('Sort changed to ' + sort_value);

		var num_total = num_train + num_val;
		var index_list = [];

		var lf_matrix = (use_noext_data) ? lf_matrix_noext : lf_matrix_ext;

		// for each datapoint, compute its value that is to be used in the sort
		for (var i=0; i<num_total; i++) {

			// by default, value is the position in the original list
			var value = i;

			if (sort_value == "sort_by_label_model") {
				// use label model score
				value = prob_labels_noext[i];
			} else if (sort_value == "sort_by_ground_truth_label") {
				// use ground truth label
				value = ground_truth_labels[i];
			} else {
				// use the count of positives, negatives, or abstains
				var num_positive = 0;
				var num_negative = 0;
				var num_abstain = 0;
				for (var j=0; j<num_lf; j++) {
					var idx = i*num_lf + j;
					if (lf_matrix[idx] == 0)
						num_abstain++;
					else if (lf_matrix[idx] == 1)
						num_positive++;
					else if (lf_matrix[idx] == -1)
						num_negative++;
				}

				if (sort_value == "sort_by_num_positive")
					value = num_positive;
				else if (sort_value == "sort_by_num_negative")
					value = num_negative;
				else if (sort_value == "sort_by_num_abstain")
					value = num_abstain;
			}
			index_list.push([i, value]);
		}

		index_list.sort(sort_ascending_function);

		row_sorting = [];
		for (var i=0; i<num_total; i++) {
			row_sorting.push(index_list[i][0]);
		}

		lfviz.set_row_sorting(row_sorting);
	}

	function handle_onload() {

		var main_canvas = document.getElementById('main_canvas');
		var preview_div = document.getElementById('preview_div');

		lfviz.init(main_canvas, preview_div);
		load_data();
	}

</script>
</head>

<body onload="handle_onload()">

<div id="labeled_div">
	<canvas id="main_canvas" width="940" height="550" style="border: 1px solid #c0c0c0; display: block; float: left;" ></canvas>
	<div id="preview_div" style="padding-left: 5px; width: 256px; height: 500px; float: left;">&nbsp;</div>
</div>

<div style="clear: both;">
	<span id="toggle_extended_text">Showing data BEFORE extension.</span>
	<button id="toggle_extended_button" type="button" onclick="handle_toggle_show_extended()">Show Post-Extension Data</button>
</div>

<div>
Sort rows by
	<select id="sort_by_selection" onchange="handle_sort_change()">
       <option value="sort_by_none">Original data order</option>
       <option value="sort_by_label_model">Label model score</option>
       <option value="sort_by_ground_truth_label">Ground truth label</option>
       <option value="sort_by_num_positive">Num positive votes</option>
       <option value="sort_by_num_negative">Num negative votes</option>
       <option value="sort_by_num_abstain">Num abstains</option>
    </select>
</div>

<div>
	Only show data points where 
	<select id="select_lf">
       <option value="lf_all">all labeling funcs</option>
       <option value="lf_all_voting">all voting labeling funcs</option>
       <option value="lf_any">any labeling func</option>
    </select>
    is
    <select id="select_lf_status">
       <option value="positive">positive</option>
       <option value="negative">negative</option>
       <option value="abstain">abstains</option>
       <option value="disagree">votes, but disagrees</option>
    </select>
    .

    <button type="button" onclick="handle_change_row_filter_mask()">Set Filter</button>
    <button type="button" onclick="handle_clear_row_filter_mask()">Clear Filter</button>
</div>


<h3>Dataset Info</h3>

<div id="data_info">No data loaded.</div>

<h3>Help</h3>

<p>
	<div>Hover over a row to see the data point.</div>
	<div>Click to "lock in" a selection of a data point.  Click anywhere a second time to unlock the selection and return to hover behavior.</div>
</p>

<p>
<div>Green - positive vote</div>
<div>Red - positive vote</div>
<div>Gray - abstain</div>
</p>

</body>
</html>