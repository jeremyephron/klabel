<!DOCTYPE html>
<html>
<head>
	<title>Labeling Function Viz</title>

<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">

<style>

	body {
		font-family: Open sans, Arial, sans-serif;
		font-size: 10pt;
		font-weight: 400;
		color: #606060;
		background: #ffffff;
	}

	body a {
		color: #808080;
	}

	body a:hover {
		text-decoration: underline;
	}

	body h3 {
		color: #000000;
	}

	button {
	  background-color: #a2a2a2; 
	  border: none;
	  color: white;
	  padding: 2px 6px;
	  border-radius: 3px;
 	  /*font-family: Open sans, Arial, sans-serif; */
	  text-align: center;
	  display: inline-block;
	}

	button:hover {
		background-color: #808080;
	}

	.bold_text {
		font-weight: bold;
	}

	.image_thumb {
		border: 1px solid #808080;
		margin: 1px;
	}

	.text_main_preview {
		width: 250px;
		height: 200px;
		border: 1px solid #808080;
		border-bottom: 5px solid #808080;
		background-color:#e0e0e0;
		padding: 4px;
		overflow: scroll;
	}

	.text_similarity_preview {
		border: 1px solid #808080;
		background-color:#e0e0e0;
		padding: 4px;
		margin-top: 10px;
	}

	.datapoint_positive {
		border-bottom: 5px solid #67bf5c;
	}

	.datapoint_negative {
		border-bottom: 5px solid #ed665d;
	}

	.datapoint_unknown {
		border-bottom: 5px solid #808080;
	}

</style>

<script src="js/kmath.js"></script>
<script src="js/widgets/lfviz.js"></script>
<script src="js/widgets/anim_thumb.js"></script>

<script>

	// FIXME(kayvonf): hacky enum.
	// Need to figure out what is the right way to do this in Javascript
	var LF_OUTPUT_NEGATIVE = -1;
	var LF_OUTPUT_ABSTAIN = 0;
	var LF_OUTPUT_POSITIVE = 1;
	var LF_OUTPUT_VOTES = 2;
	var LF_OUTPUT_AGREES = 3;
	var LF_OUTPUT_DISAGREES = 4;
    var LF_OUTPUT_EXISTS = 5;
    var LF_OUTPUT_CORRECT = 6;
    var LF_OUTPUT_INCORRECT = 7;
    var LF_OUTPUT_UNKNOWN = 8;

	var DATAPOINT_TYPE_UNKNOWN = 0;
	var DATAPOINT_TYPE_TEXT = 1;
	var DATAPOINT_TYPE_IMAGE_URL = 2;
	var DATAPOINT_TYPE_IMAGE_URL_SEQ = 3;

	// append part2 to part1 to create a path (similar to os.path.join() in Python)
	function join_path(part1, part2) {
		var prefix = part1;
		if (prefix.charAt(prefix.length-1))
			prefix = prefix + "/";
		return prefix + part2;
	}

	// extract the directory part of a url
	function get_url_dir(dump_url) {
		var idx = dump_url.lastIndexOf('/');
		if (idx == -1)
			return "";
		else
			return dump_url.substr(0, idx+1);
	}
	
	// return true is a url string is an absolute url, false otherwise
	function is_absolute_url(url) {
		return (url.indexOf("http://") == 0 ||
				url.indexOf("https://") == 0 ||
				url.indexOf("/") == 0);
	}

	class FilterDef {
		constructor(filter, options) {
			this.filter = filter;
			this.options = options;
		}
	}

	///////////////////////////////////////////////////////////
	// input data (from the debug dump) 
	///////////////////////////////////////////////////////////

	var dump_name;
	var dump_base_dir;

	var num_train = 0;
	var num_val = 0;
	var num_lf = 0;

	var has_extended_data;
	var has_similarity_data;

	// human-readable names for all the labeling functions
	var lf_names;

	// the source data type: text strings (if text), or an image url
	var datapoint_type;

	// information about each datapoint (used for previewing it)
	var datapoints;
	
	// table of labeling function outputs (pre and post LF extension)
	var lf_matrix_noext;
	var lf_matrix_ext;
	
	// label model output (pre and post LF extension)
	var prob_labels_noext;
	var prob_labels_ext;

	// ground truth labels
	var ground_truth_labels;

	// for each datapoint, ranking of all other datapoints in terms of closeness in feature space
	// (in other words, the sorted distance matrix)
	var similarity_rankings;

	///////////////////////////////////////////////////////////
	// viz application state
	///////////////////////////////////////////////////////////

	var LFVIZ_CONFIG_FILE_DIR = 'lfviz_config';

	var lfviz_widget = new LFViz;

	// index of datapoint in preview pane
	var cur_preview_idx;

	// index of datapoint whose similarity results are shown
	var cur_similarity_idx;

	// data structure managing the state of the possible data_filters
	var available_filters;

	// whether or not to show the results from the "extended" labeling functions
	var display_ext_data;

	// This mask denoting the rows that should be rendered in the visualizer
	var row_filter_mask;

	// the number of 1's in the row_filter_mask
	var num_datapoints_pass_filter;

	// sorting of the rows in the visualizer
	var row_sorting;

	// state of the async loads
	var pending_data_load_events;

	// key DOM elements 
	var loading_div;         // where to render datapoint previews
	var main_viz_div;        // main div for all the UI elements
	var main_preview_div;    // div containing the main preview
	var thumbnail_list_div;  // div containing all the thumbnails

	// handles thumbnail animation
	var main_preview_image_widget = new AnimatedThumbnailWidget;
	var thumbnail_list_widget = new AnimatedThumbnailWidget;

	// hide any indication of ground truth data in the UI, even if it exists in the dataset
	var hide_ground_truth = false;

	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////

	// Entrypoint that initiates logic for loading data from the server via a sequence of async requests 
	//
	// First, the app loads the dataset "info file", which contains a bunch of metadata about the dataset.
	// After the info file has loaded, then the app fires off a collection of various async requests
	// (via Javascript's Fetch API) to get all the associated data files.  
	//
	// See handle_data_load_complete() for the logic that occurs when all data has loaded. 
	function load_data(dump_url) {

		console.log("Loading weakdb data dump: " + dump_url);

 		fetch(dump_url)
 			.then(function(response) {
 				if (response.status !== 200) {
 					console.log("problem: " + response.status);
 				}
 				return response.json();
			})
			.then(function(data) {

				handle_info_file_loaded(data);

				// determine how many async file loads are necessary. This depends on what data is available.
				pending_data_load_events = 7;

				if (!has_extended_data)
					pending_data_load_events-=2;
				if (!has_similarity_data)
					pending_data_load_events--;

				// FIXME(kayvonf): this is hacky. If the ground truth label array has already been filled in,
				// they are filled in with "0's" corresponding to "unknown". That means that ground truth labels
				// are are not in the dataset and need not be loaded.
				var do_load_ground_truth = true;
				if (ground_truth_labels.length == (num_train + num_val)) {
					do_load_ground_truth = false;
					pending_data_load_events--;
				}

				// now kick off all the individual data file loads
				var prefix = join_path(dump_base_dir, dump_name);
				var lf_matrix_noext_url = prefix + '_lfmatrix_noext.json';
				var prob_labels_noext_url = prefix + '_prob_labels_noext.json';
				var lf_matrix_ext_url = prefix + '_lfmatrix_ext.json';
				var prob_labels_ext_url = prefix + '_prob_labels_ext.json';
				var datapoints_url = prefix + '_datapoints.json';
				var ground_truth_labels_url = prefix + '_ground_truth_labels.json';
				var dist_ranking_url = prefix + '_sorted_dists.json';

		 		fetch(lf_matrix_noext_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						lf_matrix_noext = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching LF matrix (noext) data: ', err);
		 			});

		 		fetch(prob_labels_noext_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						prob_labels_noext = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching LM (noext) output: ', err);
		 			});

		 		fetch(datapoints_url)
		 			.then(function(response) {
		 				if (response.status !== 200) {
		 					console.log("problem: " + response.status);
		 				}
		 				return response.json();
					})
					.then(function(data) {
						datapoints = data;
						handle_data_load_event();
					})
		 			.catch(function(err) {
		 				console.log('Error fetching datapoints: ', err);
		 			});

		 		if (has_extended_data) {
			 		fetch(lf_matrix_ext_url)
			 			.then(function(response) {
			 				if (response.status !== 200) {
			 					console.log("problem: " + response.status);
			 				}
			 				return response.json();
						})
						.then(function(data) {
							lf_matrix_ext = data;
							handle_data_load_event();
						})
			 			.catch(function(err) {
			 				console.log('Error fetching LF matrix (ext) data: ', err);
			 			});

			 		fetch(prob_labels_ext_url)
			 			.then(function(response) {
			 				if (response.status !== 200) {
			 					console.log("problem: " + response.status);
			 				}
			 				return response.json();
						})
						.then(function(data) {
							prob_labels_ext = data;
							handle_data_load_event();
						})
			 			.catch(function(err) {
			 				console.log('Error fetching LM (ext) output: ', err);
			 			});
		 		}

		 		if (do_load_ground_truth) {
			 		fetch(ground_truth_labels_url)
			 			.then(function(response) {
			 				if (response.status !== 200) {
			 					console.log("problem: " + response.status);
			 				}
			 				return response.json();
						})
						.then(function(data) {
							ground_truth_labels = data;
							handle_data_load_event();
						})
			 			.catch(function(err) {
			 				console.log('Error fetching ground truth data: ', err);
			 			});
		 		}

		 		if (has_similarity_data) {
			 		fetch(dist_ranking_url)
			 			.then(function(response) {
			 				if (response.status !== 200) {
			 					console.log("problem: " + response.status);
			 				}
			 				return response.json();
						})
						.then(function(data) {
							similarity_rankings = data;
							handle_data_load_event();
						})
			 			.catch(function(err) {
			 				console.log('Error fetching ground truth data: ', err);
			 			});
		 		}

			})
 			.catch(function(err) {
 				console.log('Error fetching dataset info file: ', err);
 			});
	}

	// called when the dataset info file has been downloaded
	function handle_info_file_loaded(info) {

		dump_name = info.name;

		num_lf = info.num_lf;
		num_train = info.num_train;
		num_val = info.num_val;
		dataset_description = info.description;
		lf_names = info.lf_names;

		if (info.datatype == "text")
			datapoint_type = DATAPOINT_TYPE_TEXT;
		else if (info.datatype == "image_url")
			datapoint_type = DATAPOINT_TYPE_IMAGE_URL;
		else if (info.datatype == "image_url_seq")
			datapoint_type = DATAPOINT_TYPE_IMAGE_URL_SEQ;
		else
			datapoint_type = DATAPOINT_TYPE_UNKNOWN;

		has_similarity_data = info.has_similarity_data;
		has_extended_data = info.has_extended_data;

		lf_matrix_noext = [];
		prob_labels_noext = [];

		lf_matrix_ext = [];
  		prob_labels_ext = [];
  		
  		ground_truth_labels = [];
 		datapoints = [];

 		// if no ground truth data, fill in all 0's ("unknown")
		if (!info.has_ground_truth) {
			var num_total = num_train + num_val;
			for (var i=0; i<num_total; i++) {
				ground_truth_labels[i] = 0;
			}
		}
	}

	// called upon completion of a dataset data file download
	function handle_data_load_event() {
		pending_data_load_events--;

		// all data is loaded, we can now take action to load the viz widget
		if (pending_data_load_events == 0)
			handle_data_load_complete();
	}

	// called when all dataset data has been loaded
	// See load_data() for the logic used to initiate all the data load requests
	function handle_data_load_complete() {
		var num_total = num_train + num_val;

		// if the type of the data is an image url, need to patch up the urls to make
		// them relative to dump_base_dir (unless URL is absolute)
		if (datapoint_type == DATAPOINT_TYPE_IMAGE_URL) {
			for (var i=0; i<num_total; i++)
				if (!is_absolute_url(datapoints[i]))
					datapoints[i] = join_path(dump_base_dir, datapoints[i]);

		} else if (datapoint_type == DATAPOINT_TYPE_IMAGE_URL_SEQ) {
			for (var i=0; i<num_total; i++)
				for (var j=0; j<datapoints[i].length; j++)
					if (!is_absolute_url(datapoints[i][j]))
					datapoints[i][j] = join_path(dump_base_dir, datapoints[i][j]);
		}

		// run a bunch of checks on the integrity of the data
		if (!check_data_sanity())
			alert("Data in dump file did not pass sanity check.");

		console.log("Data load complete (train size=" + num_train + ", val size=" + num_val + ", num LFs=" + num_lf + ")");

		// update the filter selection dropdown box to include options for the various labeling functions
		setup_filters();

		// update the DOM to display stats about the dataset 
		var data_info_el = document.getElementById('data_info');  
		var contents = "<p>";
		contents += "<div>Description: " + dataset_description + "</div>";
		contents += "<div>Num datapoints: " + (num_train + num_val) + "</div>";
		contents += "<div>Num train: " + num_train + "</div>";
		contents += "<div>Num val: " + num_val + "</div>";
		contents += "<div>Num LFs: " + num_lf + "</div>";
		contents += "<div>LF Names: ";
		for (var i=0; i<num_lf; i++) {
			contents += lf_names[i];
			if (i < num_lf-1)
				contents += ", "
		}
		contents += "</p>"
		data_info_el.innerHTML = contents;			

		display_ext_data = false;
		if (has_extended_data) {
			var button = document.getElementById("toggle_extended_button");
			button.style.visibility = "visible";
		}

		cur_preview_idx = -1;
		cur_similarity_idx = -1;

		loading_div.style.visibility = 'hidden';
		main_viz_div.style.visibility = 'visible';

		// communicate data to the viz widget
		var lf_matrix = display_ext_data ? lf_matrix_ext : lf_matrix_noext;
		var prob_labels = display_ext_data ? prob_labels_ext : prob_labels_noext;
		lfviz_widget.set_data(num_total, num_lf, lf_matrix, prob_labels, handle_show_data_preview);

		// data has been reset. Clear any filters, and recompute sort
		
		// FIXME(kayvonf): code duplication with contents of handle_filter_change()
		row_filter_mask = [];
		for (var i=0; i<num_total; i++)
			row_filter_mask[i] = true;
		num_datapoints_pass_filter = num_train + num_val;

		lfviz_widget.set_row_filter_mask(row_filter_mask);
		handle_sort_change();
		clear_datapoints_viz_list();
	}

	// Check consistency of dataset. Verifies that the size of downloaded
	// data files matches what is reported in the metadata files of the
	// dataset info file.
	function check_data_sanity() {

		var num_total = num_train + num_val;
		var check_passed = true;

		if (lf_names.length != num_lf) {
			console.log("WARNING: Unexpected number of labeling function names. Expected " + num_lf + ", data has " + lf_names.length);
			check_passed = false;

		} else if (datapoints.length != num_total) {
			console.log("WARNING: Unexpected number of datapoint values. Expected " + num_total + ", data has " + datapoints.length);		
			check_passed = false;

		} else if (datapoint_type == DATAPOINT_TYPE_UNKNOWN) {
			console.log("WARNING: Unknown datapoint type.");
			check_passed = false;

		} else if (ground_truth_labels.length != num_total) {
			console.log("WARNING: Unexpected number of ground truth labels. Expected " + num_total + ", data has " + ground_truth_labels.length);
			check_passed = false;

		} else if (lf_matrix_noext.length != num_total * num_lf) {
			console.log("WARNING: Unexpected number of lf matrix values (noext). Expected " + (num_total * num_lf) + ", data has " + lf_matrix_noext.length);		
			check_passed = false;

		} else if (has_extended_data && lf_matrix_ext.length != num_total * num_lf) {
			console.log("WARNING: Unexpected number of lf matrix values (ext). Expected " + (num_total * num_lf) + ", data has " + lf_matrix_ext.length);		
			check_passed = false;
		
		} else if (has_extended_data && prob_labels_ext.length != num_total) {
			console.log("WARNING: Unexpected number of label model values (ext). Expected " + num_total + ", data has " + label_model_ext.length);		
			check_passed = false;
		
		} else if (prob_labels_noext.length != num_total) {
			console.log("WARNING: Unexpected number of label model values (noext). Expected " + num_total + ", data has " + label_model_noext.length);		
			check_passed = false;
		
		} else if (has_similarity_data && similarity_rankings.length != num_total) {
			console.log("WARNING: Unexpected number of ranking lists. Expected " + num_total + ", data has " + similarity_rankings.length);		
			check_passed = false;	
		}

		return check_passed;
	}

	function handle_select_datapoint(datapoint_idx) {
		lfviz_widget.set_selection(datapoint_idx);
	}

	function handle_select_datapoint_from_input_box() {
		var input_el = document.getElementById("select_input_box");
		var value = parseInt(input_el.value);
		if (!isNaN(value))
			lfviz_widget.set_selection(value);
		else
			input_el.value = '';
	}

	function handle_thumbnail_mouseover(datapoint_idx) {
		var img_el = document.getElementById("thumbnail_image_" + datapoint_idx);
		thumbnail_list_widget.attach(img_el, datapoint_idx, datapoints[datapoint_idx], false);
	}

	function handle_thumbnail_mouseout(datapoint_idx) {
		thumbnail_list_widget.detach();
	}

	function create_list_text(items) {

		var num_items = items.length;

		var str = "<div>";
		for (var i=0; i<num_items; i++) {
			var neighbor_idx = items[i];

			var style_override = "";
			if (!hide_ground_truth) {
				if (ground_truth_labels[neighbor_idx] == 1)
					style_override = "datapoint_positive";
				else if (ground_truth_labels[neighbor_idx] == -1)
					style_override = "datapoint_negative";
			}	

			str += "<div class=\"text_similarity_preview " + style_override + "\">";
			str += "<div>";
			str += datapoints[neighbor_idx];
			str += "</div>";
			str += "<button onclick=\"handle_select_datapoint(" + neighbor_idx + ")\">Select</button>";
			str += "</div>"
		}
		str += "</div>";
		return str;
	}

	function create_list_images(items) {

		num_items = items.length;

		var str = "<div>";
		for (var i=0; i<num_items; i++) {

			var neighbor_idx = items[i];
			
			var img_url;
			var img_events_str;

			// FIXME(kayvonf): I currently hardcoded index to '1' for IMAGE_URL_SEQ case
			if (datapoint_type == DATAPOINT_TYPE_IMAGE_URL) {
				img_url = datapoints[neighbor_idx];
				img_events_str = "";
			} else {
				img_url = datapoints[neighbor_idx][1];
				img_events_str = "onmouseover=\"handle_thumbnail_mouseover(" + neighbor_idx + ")\" onmouseout=\"handle_thumbnail_mouseout(" + neighbor_idx + ")\"";
			}

			var style_override = "datapoint_unknown";
			if (!hide_ground_truth) {
				if (ground_truth_labels[neighbor_idx] == 1)
					style_override = "datapoint_positive";
				else if (ground_truth_labels[neighbor_idx] == -1)
					style_override = "datapoint_negative";
			}	

			str += "<a href=\"#\" onclick=\"handle_select_datapoint(" + neighbor_idx + ")\">";
			str += "<img id=\"thumbnail_image_" + neighbor_idx + "\" class=\"image_thumb " + style_override + "\" " + img_events_str + " src=\"" + img_url + "\" width=\"100\" height=\"100\" /></a>";
		}
		str += "</div>";
	
		return str;
	}

	function handle_show_similar_datapoints(idx) {

		cur_similarity_idx = idx;

		if (cur_similarity_idx == -1) {

			thumbnail_list_div.innerHTML = "";

		} else {

			var num_thumbs = Math.min(250, similarity_rankings[idx].length);

			var item_list = [];
			for (var i=0; i<num_thumbs; i++) {
				item_list.push(similarity_rankings[idx][i]);
			}

			var str = "";

			if (datapoint_type == DATAPOINT_TYPE_TEXT) {
				str += "<h3>Top " + num_thumbs + " most similar items to datapoint " + idx + "</h3>";
				str += create_list_text(item_list);
			}
			else {
				str += "<h3>Top " + num_thumbs + " most similar images to datapoint " + idx + "</h3>";
				str += create_list_images(item_list);
			}

			thumbnail_list_div.innerHTML = str;
		}
	}

	function clear_datapoints_viz_list() {
		// Don't clear list if it's a similar datapoints list. We only want to clear if the list is
		// showing a visualization of all data in the visualizer matrix that passed the current filter
		//FIXME(kayvonf): very hacky to look for there NOT being a similarity list
		if (cur_similarity_idx == -1) {
			thumbnail_list_div.innerHTML = "";
		}
	}

	function handle_show_datapoints_viz_list() {

		cur_similarity_idx = -1;

		var datapoint_list = [];
		var num_total = num_train + num_val;
		for (var i=0; i<num_total; i++) {
			var idx = row_sorting[i];
			if (row_filter_mask[idx] == true)
				datapoint_list.push(idx); 
		}

		var str = "<h3>" + datapoint_list.length + " datapoints passing the current filter (in sorted order)</h3>";

		if (datapoint_type == DATAPOINT_TYPE_TEXT) {
			str += create_list_text(datapoint_list);
		} else {
			str += create_list_images(datapoint_list);
		}

		thumbnail_list_div.innerHTML = str;
	}

	function handle_show_data_preview(idx) {

		cur_preview_idx = idx;

		if (idx == -1) {

			main_preview_image_widget.detach();
			main_preview_div.innerHTML = "";

		} else {

        	if (datapoint_type == DATAPOINT_TYPE_IMAGE_URL_SEQ)
	        	main_preview_image_widget.detach();

			var num_total = num_train + num_val;
			var lf_matrix = display_ext_data ? lf_matrix_ext : lf_matrix_noext;
			var prob_labels = display_ext_data ? prob_labels_ext : prob_labels_noext;

			var style_override = "datapoint_unknown";
			if (!hide_ground_truth) {
				if (ground_truth_labels[idx] == 1)
					style_override = "datapoint_positive";
				else if (ground_truth_labels[idx] == -1)
					style_override = "datapoint_negative";
			}	

			var str = "<p>Datapoint: " + idx + " of " + num_total + "<p/>";

			if (datapoint_type == DATAPOINT_TYPE_TEXT) {


				str += "<p><div class=\"text_main_preview " + style_override + "\">" + datapoints[idx] + "</div></p>";

			} else if (datapoint_type == DATAPOINT_TYPE_IMAGE_URL || datapoint_type == DATAPOINT_TYPE_IMAGE_URL_SEQ) {

				// FIXME(kayvonf): I currently hardcoded index for IMAGE_URL_SEQ case
				var img_url = (datapoint_type == DATAPOINT_TYPE_IMAGE_URL_SEQ) ? datapoints[idx][1] : datapoints[idx];  

				str += "<p><img id=\"main_preview_image\" class=\"image_thumb " + style_override + "\" src=\"" + img_url + "\" width=\"" +
                    	main_preview_div.clientWidth + "\" height=\"" + main_preview_div.clientWidth + "\" /></p>";
			}

			str += "<p>";

			var value_str;

			if (hide_ground_truth)
				value_str = "unknown";
			else {
				if (ground_truth_labels[idx] == 1)
					value_str = "true";
				else if (ground_truth_labels[idx] == -1)
					value_str = "false";
				else 
					value_str = "unknown";
			}

			str += "<div>Ground truth: " + value_str + "</div>";
				
			str += "<div>LM score: "+ prob_labels[idx].toPrecision(4) + "</div>"
			str += "<div>LF votes: ";
			var base = num_lf*idx;
			for (var i=0;i<num_lf; i++) {
				str += lf_matrix[base + i];
				if (i < num_lf-1)
					str += ", "; 
			}
			str += "</div>";
			str += "</p>";

            // FIXME(kayvonf): terrible hack. Hardcoding this event handler for now
            if (has_similarity_data)
	            str += "<p><a href=\"#\" onclick=\"handle_show_similar_datapoints(" + idx + ")\">View Similar Datapoints</p>"

        	main_preview_div.innerHTML = str;

        	if (datapoint_type == DATAPOINT_TYPE_IMAGE_URL_SEQ)
	        	main_preview_image_widget.attach(document.getElementById("main_preview_image"), idx, datapoints[idx], true);
		}
	}

	function setup_filters() {

		// these are the options for any individual labeling function 
		var individual_lf_options = ["positive", "negative", "abstain", "votes", "votes+disagrees", "correct", "incorrect"];

		available_filters = [];
		available_filters.push( new FilterDef("[no filter]", []) );
		available_filters.push( new FilterDef("All LFs", ["positive", "negative", "abstain", "votes"]) );
		available_filters.push( new FilterDef("All voting LFs", ["positive", "negative", "agree"]) );
		available_filters.push( new FilterDef("Any LF", ["positive", "negative", "abstain", "votes", "votes+disagrees", "correct", "incorrect"]) );
		available_filters.push( new FilterDef("Label model", ["positive", "negative", "correct", "incorrect"]) );
		available_filters.push( new FilterDef("Ground truth", ["positive", "negative", "exists"]) );
		for (var i=0; i<num_lf; i++) {
			available_filters.push( new FilterDef("LF: " + lf_names[i], individual_lf_options) );
		}

		// update the filter selection dropdown box with all the available filters
		var select_box = document.getElementById("select_lf");

		for (var i=0; i<available_filters.length; i++) {
			var option = document.createElement("option");
			option.text = available_filters[i].filter;
			option.value = available_filters[i].filter;
			select_box.appendChild(option);
		}
	}

	// "part 1" is the select of the filter type.  Note that most filters also need the user to
	// select value along with this type in order to fully specify a filter.  So this function
	// only serves to modify the options in the filter options select box to be consistent with
	// the filter chosen type.
	function handle_filter_part1_change() {

		var select_box = document.getElementById("select_lf");		
		var select_value_box = document.getElementById("select_lf_status");

		var cur_option_val = select_value_box.value;

		for (var i=0; i<available_filters.length; i++) {
			if (available_filters[i].filter == select_box.value) {

				// clear out the old
				select_value_box.innerHTML = "";
							
				for (var j=0; j<available_filters[i].options.length; j++) {
					var option = document.createElement("option");
					option.text = available_filters[i].options[j];
					option.value = available_filters[i].options[j];
					select_value_box.appendChild(option);

					// for user convenince, if the option for the only filter is still valid for the new filter, keep it!
					if (option.value == cur_option_val) {
						option.selected = true;
					}				
				}

				handle_filter_change();
				break;
			}
		}
	}

	// Filters rows according to a predicate and stores result in row_filter_mask
	function handle_filter_change() {

		var lf_select = 0;
		var lf_value = 1;
		var select_lf_box = document.getElementById("select_lf");
		var select_value_box = document.getElementById("select_lf_status");

		row_filter_mask = [];

		var num_total = num_train + num_val;
		var lf_matrix = (display_ext_data) ? lf_matrix_ext : lf_matrix_noext;	
		var prob_labels = (display_ext_data) ? prob_labels_ext : prob_labels_noext;

		var criteria;
		if (select_value_box.value == "positive")
			criteria = LF_OUTPUT_POSITIVE;
		else if (select_value_box.value == "negative")
			criteria = LF_OUTPUT_NEGATIVE;
		else if (select_value_box.value == "abstain")
			criteria = LF_OUTPUT_ABSTAIN;
		else if (select_value_box.value == "votes")
			criteria = LF_OUTPUT_VOTES;
		else if (select_value_box.value == "agree")
			criteria = LF_OUTPUT_AGREES;
		else if (select_value_box.value == "votes+disagrees")
			criteria = LF_OUTPUT_DISAGREES;
		else if (select_value_box.value == "exists")
			criteria = LF_OUTPUT_EXISTS;
		else if (select_value_box.value == "correct")
			criteria = LF_OUTPUT_CORRECT;
		else if (select_value_box.value == "incorrect")
			criteria = LF_OUTPUT_INCORRECT;
		else {
			criteria = LF_OUTPUT_UNKNOWN;
		}

		if (select_lf_box.value == "[no filter]") {
			for (var i=0; i<num_total; i++) {
				row_filter_mask[i] = true;
			}		
		}

		else if (select_lf_box.value == "All LFs") {
			// ["positive", "negative", "abstain", "votes"]

			for (var i=0; i<num_total; i++) {
				row_filter_mask[i] = true;
				var idx = i*num_lf;
				for (var j=0; j<num_lf; j++) {
					if (criteria == LF_OUTPUT_VOTES && lf_matrix[idx + j] == 0)
						row_filter_mask[i] = false;
					if (criteria != LF_OUTPUT_VOTES && lf_matrix[idx+j] != criteria)
						row_filter_mask[i] = false;
				}
			}	
		}

		else if (select_lf_box.value == "All voting LFs") {
			// ["positive", "negative", "agree"]
			
			for (var i=0; i<num_total; i++) {

				row_filter_mask[i] = true;

				var idx = i*num_lf;
				var num_votes = 0;
				var agree_value;

				for (var j=0; j<num_lf; j++) {

					// LF does not vote
					if (lf_matrix[idx + j] == LF_OUTPUT_ABSTAIN)
						continue;
					
					num_votes++;

					// record the vote of the first LF that votes
					if (num_votes == 1)
						agree_value = lf_matrix[idx + j];

					// require agreement
					if (criteria == LF_OUTPUT_AGREES) {
						if (num_votes > 1 && lf_matrix[idx + j] != agree_value) {
							// disagreement detected
							row_filter_mask[i] = false;
						}
					} else if (lf_matrix[idx + j] != criteria) {
						row_filter_mask[i] = false;
					}
				}

				// row shouldn't pass an "all voting LFs" filter if there are no voting LFs
				// FIXME(kayvonf): We current allow a row to pass the filter "all voting LFs agree" even if
				// there is only 1 voting LF.  Is this the desired behavior?
				if (num_votes == 0)
					row_filter_mask[i] = false;
			}
		}

		else if (select_lf_box.value == "Any LF") {
			// ["positive", "negative", "abstain", "votes", "votes+disagrees", "correct", "incorrect"]

			for (var i=0; i<num_total; i++) {
				row_filter_mask[i] = false;

				var idx = i*num_lf;
				for (var j=0; j<num_lf; j++) {

					if ( (criteria == LF_OUTPUT_POSITIVE || criteria == LF_OUTPUT_NEGATIVE || criteria == LF_OUTPUT_ABSTAIN) && lf_matrix[idx+j] == criteria) {
						row_filter_mask[i] = true;
						break;
					}

					else if (criteria == LF_OUTPUT_VOTES && lf_matrix[idx+j] != LF_OUTPUT_ABSTAIN) {
						row_filter_mask[i] = true;
						break;
					}

					else if (criteria == LF_OUTPUT_CORRECT && lf_matrix[idx+j] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+j] == ground_truth_labels[i]) {
						row_filter_mask[i] = true;
						break;				
					}

					else if (criteria == LF_OUTPUT_INCORRECT && lf_matrix[idx+j] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+j] != ground_truth_labels[i]) {
						row_filter_mask[i] = true;
						break;	
					}

					else if (criteria == LF_OUTPUT_DISAGREES) {
						for (var k=0; k<num_lf; k++) {
							if (j != k && 
								lf_matrix[idx+j] != LF_OUTPUT_ABSTAIN &&
								lf_matrix[idx+k] != LF_OUTPUT_ABSTAIN &&
								lf_matrix[idx+j] != lf_matrix[idx+k]) {
								row_filter_mask[i] = true;
								break;
							}
						}

						if (row_filter_mask[i] == true)
							break;
					}
				}
			}
		}

		else if (select_lf_box.value == "Label model") {
			// ["positive", "negative", "correct", "incorrect"]

			for (var i=0; i<num_total; i++) {
				var label_model_result = (prob_labels[i] >= 0.5) ? LF_OUTPUT_POSITIVE : LF_OUTPUT_NEGATIVE;

				if ( ((criteria == LF_OUTPUT_POSITIVE || criteria == LF_OUTPUT_NEGATIVE) && label_model_result == criteria) ||
					 (criteria == LF_OUTPUT_CORRECT   && label_model_result == ground_truth_labels[i]) ||
					 (criteria == LF_OUTPUT_INCORRECT && label_model_result != ground_truth_labels[i]) ) {
					row_filter_mask[i] = true;
				}
			}

		}

		else if (select_lf_box.value == "Ground truth") {
			// ["positive", "negative", "exists"]

			for (var i=0; i<num_total; i++) {
				if ( (criteria == LF_OUTPUT_EXISTS && (ground_truth_labels[i] == LF_OUTPUT_POSITIVE ||
					                                   ground_truth_labels[i] == LF_OUTPUT_NEGATIVE)) ||
				    (criteria != LF_OUTPUT_EXISTS && ground_truth_labels[i] == criteria))
					row_filter_mask[i] = true;
			}
		}

		else {
			// individual labeling function
			var lf_select;
			for (var i=0; i<num_lf; i++) {
				if ("LF: " + lf_names[i] == select_lf_box.value) {
					lf_select = i;
					break;
				}
			}
			// ["positive", "negative", "abstain", "votes", "votes+disagrees"]

			for (var i=0; i<num_total; i++) {			

				row_filter_mask[i] = false;
				var idx = i*num_lf;

				// FIXME(kayvonf): the logic below is all code that is duplicated from the "Any LF case" above (needs refactor!)

				if ( (criteria == LF_OUTPUT_POSITIVE || criteria == LF_OUTPUT_NEGATIVE || criteria == LF_OUTPUT_ABSTAIN) && lf_matrix[idx+lf_select] == criteria) {
					row_filter_mask[i] = true;
				}

				else if (criteria == LF_OUTPUT_VOTES && lf_matrix[idx+lf_select] != LF_OUTPUT_ABSTAIN) {
					row_filter_mask[i] = true;
				}

				else if (criteria == LF_OUTPUT_CORRECT && lf_matrix[idx+lf_select] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+lf_select] == ground_truth_labels[i]) {
					row_filter_mask[i] = true;			
				}

				else if (criteria == LF_OUTPUT_INCORRECT && lf_matrix[idx+lf_select] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+lf_select] != ground_truth_labels[i]) {
					row_filter_mask[i] = true;	
				}

				else if (criteria == LF_OUTPUT_DISAGREES) {
					for (var k=0; k<num_lf; k++) {
						if (lf_select != k && 
							lf_matrix[idx+lf_select] != LF_OUTPUT_ABSTAIN &&
							lf_matrix[idx+k] != LF_OUTPUT_ABSTAIN &&
							lf_matrix[idx+lf_select] != lf_matrix[idx+k]) {
							row_filter_mask[i] = true;
							break;
						}
					}
				}
			}
		}

		num_datapoints_pass_filter = 0;
		for (var i=0; i<num_total; i++) {
			if (row_filter_mask[i] == true)
				num_datapoints_pass_filter++;
		}

		if (num_datapoints_pass_filter < num_total) {
			var num_passed_el = document.getElementById("select_lf_num_passed");
			num_passed_el.innerHTML = "(" + num_datapoints_pass_filter + " datapoints pass filter)";
		}

		lfviz_widget.set_row_filter_mask(row_filter_mask);
		clear_datapoints_viz_list();
	}

	// toggles the visualizer between displaying data from LF's that have not
	// been extended and those that have been extended
	function handle_toggle_show_extended_data() {

		if (!has_extended_data)
			return;

		display_ext_data = !display_ext_data;

		var lf_matrix;
		var prob_labels;

		var button = document.getElementById("toggle_extended_button");
		var text = document.getElementById("toggle_extended_text");

		if (display_ext_data) {
			lf_matrix = lf_matrix_ext;
			prob_labels = prob_labels_ext;
			text.innerHTML = 'Showing data with LF extension.';
			button.innerHTML = 'Show Not-Extended Data';
		} else {
			lf_matrix = lf_matrix_noext;
			prob_labels = prob_labels_noext;
			text.innerHTML = 'Showing data without LF extension.';
			button.innerHTML = 'Show Extended Data';
		}

		// update data in the viz widget
		lfviz_widget.update_data(lf_matrix, prob_labels);

		// recompute masks and sorts since the data input to these operations has changed
		handle_filter_change();
		handle_sort_change();

		clear_datapoints_viz_list();
	}

	function handle_toggle_hide_ground_truth() {

		var button = document.getElementById("toggle_hide_ground_truth_button");
		hide_ground_truth = !hide_ground_truth;

		if (hide_ground_truth) {
			button.innerHTML = "Show Ground Truth";
		} else {
			button.innerHTML = "Hide Ground Truth";
		}

		// redraw the preview and similarity thumbnail sections to reflect
		// the new state of hide_ground_truth
		handle_show_similar_datapoints(cur_similarity_idx);
		handle_show_data_preview(cur_preview_idx);
	}

	// sorting predicate
	function sort_ascending_function(el1, el2) {

		if (el1[1] < el2[1])
			return -1;
		else if (el1[1] > el2[1])
			return 1;
		return 0;
	}
	
	// handle a user-specified change to the value used to sort the datapoints
	function handle_sort_change() {

		var sort_box = document.getElementById('sort_by_selection');
		var sort_value = sort_box.value;

		var num_total = num_train + num_val;
		var lf_matrix = (display_ext_data) ? lf_matrix_ext : lf_matrix_noext;
		var prob_labels = (display_ext_data) ? prob_labels_ext : prob_labels_noext;

		var index_list = [];

		// for each datapoint, compute its value that is to be used in the sort
		for (var i=0; i<num_total; i++) {

			// by default, value is the position in the original list
			var value = i;

			if (sort_value == "sort_by_label_model") {	
				// use label model score
				value = prob_labels[i];
			} else if (sort_value == "sort_by_ground_truth_label") {
				// use ground truth label
				value = ground_truth_labels[i];
			} else if (sort_value == "sort_by_change_from_extension") {
				// sort key is the change in label model output between the extended and non-extensed label models					
				value = prob_labels_ext[i] - prob_labels_noext[i];
			} else {
				// use the count of positives, negatives, or abstains
				var num_positive = 0;
				var num_negative = 0;
				var num_abstain = 0;
				for (var j=0; j<num_lf; j++) {
					var idx = i*num_lf + j;
					if (lf_matrix[idx] == 0)
						num_abstain++;
					else if (lf_matrix[idx] == 1)
						num_positive++;
					else if (lf_matrix[idx] == -1)
						num_negative++;
				}

				if (sort_value == "sort_by_num_positive")
					value = num_positive;
				else if (sort_value == "sort_by_num_negative")
					value = num_negative;
				else if (sort_value == "sort_by_num_vote")
					value = num_positive + num_negative;
			}
			index_list.push([i, value]);
		}

		index_list.sort(sort_ascending_function);

		row_sorting = [];
		for (var i=0; i<num_total; i++) {
			row_sorting.push(index_list[i][0]);
		}

		lfviz_widget.set_row_sorting(row_sorting);
		clear_datapoints_viz_list()
	}

	function handle_onload() {

		main_preview_div = document.getElementById('main_preview_div');
		loading_div = document.getElementById('loading_div');
		main_viz_div = document.getElementById('main_viz_div');
		thumbnail_list_div = document.getElementById('thumbnail_list_div');

		// generate a lfviz config file url

		var config_filename = "lfviz_config.json";
  		
		const url_params = new URLSearchParams(window.location.search);
		if (url_params.has("config")) {
    		config_filename = url_params.get("config") + ".json";
  		}

  		var config_url = LFVIZ_CONFIG_FILE_DIR + "/" + config_filename;

		loading_div.innerHTML = "Loading WeakDB config: " + config_filename;

		// kick off the config file load

		fetch(config_url)
 			.then(function(response) {
 				if (response.status !== 200) {
 					console.log("problem: " + response.status);
 				}
 				return response.json();
			})
			.then(function(config_data) {

				// Config file has loaded. Get the webdb data dump to load,
				// as well as configuration parameters for the lfviz widget

				dump_url = config_data.dump_url;

  				// dump_base_dir: this is the directory where all the dump files are located

				dump_base_dir = get_url_dir(dump_url);

				// initialize lfviz widget

				var main_canvas = document.getElementById('main_canvas');

				lfviz_widget.init(
					main_canvas,
					config_data.viz_grid_width,
					config_data.viz_grid_height,
					config_data.viz_grid_box_width,
					config_data.viz_grid_box_height);
				
				// load the weakdb data dump

				load_data(dump_url);

			})
 			.catch(function(err) {
 				console.log('Error fetching config file: ', err);
 			});	
	}

</script>
</head>

<body onload="handle_onload()">

<div id="loading_div"></div>

<div id="main_viz_div" style="visibility: hidden;">

<canvas id="main_canvas" width="940" height="550" style="border: 1px solid #c0c0c0; display: block; float: left;" ></canvas>
<div id="main_preview_div" style="padding-left: 5px; width: 256px; height: 550px; float: left;">&nbsp;</div>

<p style="clear: both; padding-top: 1px;">
<table cellpadding="0" cellspacing="2">
<tr>
	<td width="75"><span class="bold_text">Data:</span></td>
	<td>
		<span id="toggle_extended_text">Showing data without LF extension.</span>
		<button id="toggle_extended_button" type="button" style="visibility: hidden;" onclick="handle_toggle_show_extended_data()">Show Extended Data</button>
	</td>
</tr>
<tr>
	<td><span class="bold_text">Sorting:</span></td>
	<td>
	Sort rows by
	<select id="sort_by_selection" onchange="handle_sort_change()">
       <option value="sort_by_none">Original data order</option>
       <option value="sort_by_label_model">Label model score</option>
       <option value="sort_by_change_from_extension">Label model change (from extension)</option>
       <option value="sort_by_ground_truth_label">Ground truth label</option>
       <option value="sort_by_num_positive">Num positive votes</option>
       <option value="sort_by_num_negative">Num negative votes</option>
       <option value="sort_by_num_vote">Num votes</option>
    </select>		
	</td>
</tr>
<tr>
	<td><span class="bold_text">Filtering:</span></td>
	<td>
Only show data points where 
	<select id="select_lf"  style="width: 175px;" onchange="handle_filter_part1_change()">
    </select>
    is
    <select id="select_lf_status" style="width: 175px;" onchange="handle_filter_change()">
    </select>
    <span id="select_lf_num_passed" style="padding-left: 20px;"></span>
	</td>	
</tr>
<tr>
	<td>
		<span class="bold_text">Misc:</span>
	</td>
	<td>
	Select datapoint:
	<input type="text" id="select_input_box" style="width: 50px" onchange="handle_select_datapoint_from_input_box()"" onfocus="this.value=''" "/> 
	<button id="select_input_box" type="button" onclick="handle_select_datapoint_from_box()">Go</button> | 
	<button id="toggle_hide_ground_truth_button" type="button" onclick="handle_toggle_hide_ground_truth()">Hide Ground Truth</button> | 
	<button id="show_unfiltered_thumbnails_button" type="button" onclick="handle_show_datapoints_viz_list()">Show All Datatpoints</button>
	</td>
</tr>
</table>
</p>

<h3>Dataset Info</h3>

<div id="data_info">No data loaded.</div>

<div id="thumbnail_list_div"></div>

<h3>Help</h3>

<p>
	<div>Hover over a row to see the corresponding data point.</div>
	<div>Click on a row to select the corresponding data point.  Click the selected row a second time (or click on a non-row area of the viz) to remove the selection and return to hover behavior.</div>
	<div>When a data point is selected, click on "view similar datapoints" to view its nearest neighbors in the training set.</div>
	<div>Clicking on any nearest neighbor thumbnail will select it in the visualizer.</div> 
</p>

<p>
<div>Green - positive vote</div>
<div>Red - positive vote</div>
<div>Gray - abstain</div>
</p>
</div> 

</body>
</html>
