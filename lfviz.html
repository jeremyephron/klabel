<!DOCTYPE html>
<html>
<head>
	<title>Labeling Function Viz</title>

<style>

	body {
		font-family: Helvetica, Arial, sans-seris;
		font-size: 10pt;
		color: #808080;
		background: #ffffff;
	}

	body a {
		color: #d0d0d0;
	}

	.bold_text {
		font-weight: bold;
	}

</style>

<script src="kmath.js"></script>
<script src="klfviz.js"></script>

<script>

	// hacky enum
	var LF_OUTPUT_POSITIVE = 1;
	var LF_OUTPUT_NEGATIVE = -1;
	var LF_OUTPUT_ABSTAIN = 0;
	var LF_OUTPUT_DISAGREE = -2;

	var BASEURL = 'lfviz_assets/'
	var INPUT_LF_MATRIX_URL = 'backhandslice_lfmatrix.json';
	var INPUT_LM_SCORE_URL = 'backhandslice_lm.json';
	var INPUT_DATAPOINTS_URL = 'backhandslice_paths.json';

	var main_canvas_id = 'main_canvas';   // this is the DOM canvas element 
	var preview_div_id = 'preview_div';   // this is the DOM canvas element 
	var lfviz = new LFViz;

	///////////////////////////////////////////////////////////
	// input data 
	///////////////////////////////////////////////////////////
	var num_rows = 0;
	var num_lf = 0;
	var datapoint_type = LFViz.DATAPOINT_TYPE_IMAGE;

	// the source data: text strings (if text), or an image url
	var source_data = [];  
	
	// table of labeling function outputs
	var lf_matrix = [];
	
	// label model score
	var model_scores  = [];

	// human-readable names of the labeling functions
	var lf_names = [];

	// This mask denoting the rows that should be rendered in the visualizer
	var row_filter_mask = [];

	// sorting of the rows in the visualizer
	var row_sorting = [];

	// sorting predicate
	function sort_ascending_function(el1, el2) {
		if (el1[1] < el2[1])
			return -1;
		else if (el1[1] > el2[1])
			return 1;
		return 0;
	}

	function load_data() {

		num_rows = 0;
		num_lf = 0;
		datapoint_type = LFViz.DATAPOINT_TYPE_IMAGE;

		lf_matrix = [];
 		lf_names = [];
 		model_score = [];
 		source_data = [];

 		pending_data_load_events = 3;

 		fetch(BASEURL + INPUT_DATAPOINTS_URL)
 			.then(function(response) {
 				if (response.status !== 200) {
 					console.log("problem: " + response.status);
 				}
 				return response.json();
			})
			.then(function(data) {
				source_data = data;
				handle_data_load_event();
			})
 			.catch(function(err) {
 				console.log('Error fetching datapoints: ', err);
 			});

 		fetch(BASEURL + INPUT_LM_SCORE_URL)
 			.then(function(response) {
 				if (response.status !== 200) {
 					console.log("problem: " + response.status);
 				}
 				return response.json();
			})
			.then(function(data) {
				model_scores = data;
				handle_data_load_event();
			})
 			.catch(function(err) {
 				console.log('Error fetching LM output: ', err);
 			});

 		fetch(BASEURL + INPUT_LF_MATRIX_URL)
 			.then(function(response) {
 				if (response.status !== 200) {
 					console.log("problem: " + response.status);
 				}
 				return response.json();
			})
			.then(function(data) {
				lf_matrix = data;
				handle_data_load_event();
			})
 			.catch(function(err) {
 				console.log('Error fetching LF matrix data: ', err);
 			});
	}

	function handle_data_load_event() {

		pending_data_load_events--;

		if (pending_data_load_events == 0) {

			num_rows = lf_matrix.length;
			if (num_rows > 0)
				num_lf = lf_matrix[0].length;

			var temp_lf_matrix = [];
			for (var i=0; i<num_rows; i++) {
				for (var j=0; j<num_lf; j++) {
					temp_lf_matrix.push(lf_matrix[i][j]);
				}
			}
			lf_matrix = temp_lf_matrix;

			var temp_source_data = []
			for (var i=0; i<num_rows; i++) {
				temp_source_data.push(BASEURL + source_data[i]);
			}
			source_data = temp_source_data;

	 		// give the LFs canonical names for now
	 		// TODO: find some way to get the names from the data source
			for (var i=0; i<num_lf; i++)
				lf_names.push("LF" + i);

			console.log("Data load complete: " + num_rows + " rows, " + num_lf + " LFs");

			lfviz.set_data(num_rows, num_lf, lf_matrix, model_scores, datapoint_type, source_data);
			reset_row_filter_mask();
		}
	}

    // HACK(kayvonf): This is a function that filters rows according to a predicate.
    // It's meant to be throwaway code for now.
    // it returns a boolean array, designating which rows should be retained.
	function compute_row_filter_mask(lf_function, criteria) {

		row_filter_mask = [];

		var disagree_check = false;
		if (criteria == -2)
			disagree_check = true;

		//
		// no filter
		//
		if (lf_function == -1) {  		
			for (var i=0; i<num_rows; i++) {
				row_filter_mask[i] = true;
			}

		//
		// all LFs match criteria
		//
		} else if (lf_function == -2) {  

			for (var i=0; i<num_rows; i++) {
				var idx = i*num_lf;
				row_filter_mask[i] = true;
				for (var j=0; j<num_lf; j++) {
					if (lf_matrix[idx + j] != criteria || lf_matrix[idx+j] == LF_OUTPUT_DISAGREE)
						row_filter_mask[i] = false;
				}
			}

		//
		// all LFs that vote match critera
		//
		} else if (lf_function == -3) { 	

			for (var i=0; i<num_rows; i++) {
				var idx = i*num_lf;
				var num_votes = 0;

				row_filter_mask[i] = true;

				for (var j=0; j<num_lf; j++) {
					if (lf_matrix[idx + j] == LF_OUTPUT_ABSTAIN)
						continue;
					
					num_votes++;
					if (lf_matrix[idx + j] != criteria || lf_matrix[idx+j] == LF_OUTPUT_DISAGREE)
						row_filter_mask[i] = false;
				}

				// row shouldn't pass an "all voting LF that..." filter if there are no voting LFs
				if (num_votes == 0)
					row_filter_mask[i] = false;
			}

		//
		// any LFs match criteria
		//
		} else if (lf_function == -4) {

			for (var i=0; i<num_rows; i++) {
				var idx = i*num_lf;
				row_filter_mask[i] = false;
				for (var j=0; j<num_lf; j++) {

					if (disagree_check) {
						for (var k=0; k<num_lf; k++) {
							if (j != k && 
								lf_matrix[idx+j] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+k] != LF_OUTPUT_ABSTAIN &&
								lf_matrix[idx+j] != lf_matrix[idx+k]) {
								row_filter_mask[i] = true; 
							}
						}

					} else {
						if (lf_matrix[idx + j] == criteria)
							row_filter_mask[i] = true;
					}
				}
			}

		//
		// specific LFs match criteria
 		//
		} else {

			for (var i=0; i<num_rows; i++) {
				var idx = i*num_lf;
				row_filter_mask[i] = false;

				if (disagree_check) {
					for (var k=0; k<num_lf; k++) {
						if (lf_function != k &&
							lf_matrix[idx+lf_function] != LF_OUTPUT_ABSTAIN && lf_matrix[idx+k] != LF_OUTPUT_ABSTAIN &&
							lf_matrix[idx+lf_function] != lf_matrix[idx+k]) {
							row_filter_mask[i] = true; 
						}
					}

				} else {
					if (lf_matrix[idx + lf_function] == criteria)
						row_filter_mask[i] = true;
				}
			}

		}

	}


	function reset_row_filter_mask() {
		compute_row_filter_mask(-1, 0);
		lfviz.set_row_filter_mask(row_filter_mask);
	}

	function create_dummy_lf_data(num_rows, num_lf, lf_matrix, model_scores) {
		for (var i = 0; i<num_rows; i++) {
			for (var j=0; j<num_lf; j++) {

				var x = Math.random();

				if (x < 1.0/5.0)
					lf_matrix[i*num_lf + j] = 1;
				else if (x < 2.0/5.0)
					lf_matrix[i*num_lf + j] = -1;
				else
					lf_matrix[i*num_lf + j] = 0;
			}

			model_scores[i] = Math.random();
		}		
	}

	function handle_create_dummy_text() {
		lf_matrix = [];
		model_scores = [];
		create_dummy_lf_data(num_rows, num_lf, lf_matrix, model_scores);

		datapoints = [];
		datapoint_type = LFViz.DATAPOINT_TYPE_TEXT;
		for (var i=0; i<num_rows; i++) {
			datapoints.push("This is the text string associated with datapoint " + i + " that the labeling functions were executed on.  LFViz will display the text on hover.");
		}

		lfviz.set_data(num_rows, num_lf, lf_matrix, model_scores, datapoint_type, datapoints);
		reset_row_filter_mask();
	}

	function handle_create_dummy_images() {
		lf_matrix = [];
		model_scores = [];
		create_dummy_lf_data(num_rows, num_lf, lf_matrix, model_scores);

		datapoints = [];
		datapoint_type = LFViz.DATAPOINT_TYPE_IMAGE;
		for (var i=0; i<num_rows; i++) {
			datapoints.push("media/image_0" + (i % 8) + ".jpg");
		}

		lfviz.set_data(num_rows, num_lf, lf_matrix, model_scores, datapoint_type, datapoints);
		reset_row_filter_mask();
	}

	function handle_clear_row_filter_mask() {
		reset_row_filter_mask();
		lfviz.set_row_filter_mask(row_filter_mask);
	}

	function handle_make_row_filter_mask() {

		var lf_select = 0;
		var lf_value = 1;
		var select_lf_box = document.getElementById("select_lf");
		var select_value_box = document.getElementById("select_lf_status");

		// which LF's to look at
		if (select_lf_box.value == "lf_all")
			lf_select = -2;
		else if (select_lf_box.value == "lf_all_voting")
			lf_select = -3;
		else if (select_lf_box.value == "lf_any")
			lf_select = -4;
		else {
			for (var i=0; i<num_lf; i++) {
				if (select_lf_box.value == ("LF" + i)) {
					lf_select = i;
					break;
				}
			}
		}
		
		// what values are important
		if (select_value_box.value == "positive")
			lf_value = LF_OUTPUT_POSITIVE;
		else if (select_value_box.value == "negative")
			lf_value = LF_OUTPUT_NEGATIVE;
		else if (select_value_box.value == "abstain")
			lf_value = LF_OUTPUT_ABSTAIN;
		else {
			lf_value = LF_OUTPUT_DISAGREE;   // disagrees
		}	

		compute_row_filter_mask(lf_select, lf_value); 
		lfviz.set_row_filter_mask(row_filter_mask);
	}

	function handle_sort_change() {
		var sort_box = document.getElementById("sort_data_selector");
		var sort_value = sort_box.value;
		console.log('Sort changed to ' + sort_value);

		var index_list = [];
		for (var i=0; i<num_rows; i++) {

			var value = i;
			if (sort_value == "sort_label_model")
				value = model_scores[i];
			else {
				var num_positive = 0;
				var num_negative = 0;
				var num_abstain = 0;
				for (var j=0; j<num_lf; j++) {
					var idx = i*num_lf + j;
					if (lf_matrix[idx] == 0)
						num_abstain++;
					else if (lf_matrix[idx] == 1)
						num_positive++;
					else if (lf_matrix[idx] == -1)
						num_negative++;
				}

				if (sort_value == "sort_num_positive")
					value = num_positive;
				else if (sort_value == "sort_num_negative")
					value = num_negative;
				else if (sort_value == "sort_num_abstain")
					value = num_abstain;
			}
			index_list.push([i, value]);
		}

		index_list.sort(sort_ascending_function);

		row_sorting = [];
		for (var i=0; i<num_rows; i++) {
			row_sorting.push(index_list[i][0]);
		}

		lfviz.set_row_sorting(row_sorting);
	}

	function handle_onload() {

		var select_box = document.getElementById("select_lf");
		for (var i=0; i<num_lf; i++) {
			var option = document.createElement("option");
			option.text = "LF" + i;
			select_box.add(option);
		}

		var main_canvas = document.getElementById(main_canvas_id);
		var preview_div = document.getElementById(preview_div_id);

		lfviz.init(main_canvas, preview_div);
		load_data();
	}

</script>
</head>

<body onload="handle_onload()">

<div id="labeled_div">
	<canvas id="main_canvas" width="960" height="500" style="border: 1px solid #c0c0c0; display: block; float: left;" ></canvas>
	<div id="preview_div" style="padding-left: 5px; width: 256px; height: 500px; float: left;">&nbsp;</div>
</div>

<div style="clear: both;">
	Highlight data points where 
	<select id="select_lf">
       <option value="lf_all">all labeling funcs</option>
       <option value="lf_all_voting">all voting labeling funcs</option>
       <option value="lf_any">any labeling func</option>
    </select>
    is
    <select id="select_lf_status">
       <option value="positive">positive</option>
       <option value="negative">negative</option>
       <option value="abstain">abstains</option>
       <option value="disagree">votes, but disagrees</option>
    </select>
    .

    <button id="make_selection" type="button" onclick="handle_make_row_filter_mask()">Go!</button>
    <button id="make_selection" type="button" onclick="handle_clear_row_filter_mask()">Clear Filter</button>
</div>

<div>
Sort rows by
	<select id="sort_data_selector" onchange="handle_sort_change()">
       <option value="sort_none">Original data order</option>
       <option value="sort_label_model">Label model score</option>
       <option value="sort_num_positive">Num positive votes</option>
       <option value="sort_num_negative">Num negative votes</option>
       <option value="sort_num_abstain">Num abstains</option>
    </select>
</div>
<!--
<div>
	<button id="dummy_text_button" type="button" onclick="handle_create_dummy_text()">Create Dummy Text Data</button>
	<button id="dummy_image_button" type="button" onclick="handle_create_dummy_images()">Create Dummy Image Data</button>
</div>
-->

<p>
<div>Green - positive vote</div>
<div>Red - positive vote</div>
<div>Gray - abstain</div>
</p>
<p>Hover over a row to see the data point.</p>

</body>
</html>